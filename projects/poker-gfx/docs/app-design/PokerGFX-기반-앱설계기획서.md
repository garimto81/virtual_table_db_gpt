# PokerGFX ì™„ì „ ë³µì œ í¬ì»¤ ë°©ì†¡ ì•± ì„¤ê³„ ê¸°íšì„œ

## ğŸ“‹ ê¸°íšì„œ ê°œìš”

### ëª©ì 
**PokerGFXì˜ ëª¨ë“  ê¸°ëŠ¥ì„ ê·¸ëŒ€ë¡œ ë³µì‚¬**í•˜ì—¬ ë™ì¼í•œ ìˆ˜ì¤€ì˜ ì „ë¬¸ì ì¸ í¬ì»¤ ë°©ì†¡ ì†”ë£¨ì…˜ì„ ê°œë°œí•˜ê¸° ìœ„í•œ ìƒì„¸ ì„¤ê³„ ë¬¸ì„œì…ë‹ˆë‹¤. RFID í•˜ë“œì›¨ì–´, ì¹´ë©”ë¼ ì œì–´, ê·¸ë˜í”½ ì˜¤ë²„ë ˆì´, ìŠ¤íŠ¸ë¦¬ë° ê¸°ëŠ¥ ë“± ëª¨ë“  ì›ë³¸ ê¸°ëŠ¥ì„ ì™„ì „íˆ êµ¬í˜„í•©ë‹ˆë‹¤.

### ê¸°ì¡´ PokerGFX ì‹œìŠ¤í…œ ë¶„ì„ ê²°ê³¼

#### PokerGFXì˜ í•µì‹¬ êµ¬ì¡°
```yaml
í˜„ì¬_ì‹œìŠ¤í…œ:
  í•˜ë“œì›¨ì–´:
    - RFID Reader (USB 3.0 + ì „ì›)
    - RFID íƒœê·¸ ë‚´ì¥ ì „ìš© ì¹´ë“œ ë°í¬
    - Windows PC (Intel i7, 16GB RAM, GTX 1080+)
    - ë‹¤ì¤‘ ë¹„ë””ì˜¤ ìº¡ì²˜ ì¥ë¹„
    
  ì†Œí”„íŠ¸ì›¨ì–´:
    - PokerGFX Server (ë©”ì¸ ì• í”Œë¦¬ì¼€ì´ì…˜)
    - Action Tracker (ë² íŒ… ì•¡ì…˜ ì…ë ¥ ì•±)
    - Studio (í¬ìŠ¤íŠ¸ í”„ë¡œë•ì…˜ í¸ì§‘)
    
  ì›Œí¬í”Œë¡œìš°:
    1. RFID í…Œì´ë¸” ìº˜ë¦¬ë¸Œë ˆì´ì…˜ (ê° ì¢Œì„ ìœ„ì¹˜ ì„¤ì •)
    2. 52ì¥ ì¹´ë“œ ê°œë³„ ë“±ë¡
    3. ë¹„ë””ì˜¤ ì†ŒìŠ¤ ì„¤ì • (ìµœëŒ€ 16ê°œ)
    4. í”Œë ˆì´ì–´ ì •ë³´ ì…ë ¥
    5. ë¼ì´ë¸Œ ë°©ì†¡ ë˜ëŠ” ë…¹í™”
```

#### ë¼ì´ì„ ìŠ¤ë³„ ê¸°ëŠ¥ ë¶„ì„
```yaml
Basic_License:
  - ë¹„ë””ì˜¤ ì†ŒìŠ¤: ìµœëŒ€ 4ê°œ
  - ê¸°ë³¸ ê·¸ë˜í”½ ìŠ¤í‚¨
  - 30ë¶„ ë”œë ˆì´
  - Action Tracker í¬í•¨
  
Pro_License:
  - ë¹„ë””ì˜¤ ì†ŒìŠ¤: ìµœëŒ€ 8ê°œ  
  - Studio í¬ìŠ¤íŠ¸ í”„ë¡œë•ì…˜
  - í”Œë ˆì´ì–´ ì‚¬ì§„/êµ­ê¸°
  - ATEM ìŠ¤ìœ„ì²˜ ì œì–´
  - 60ë¶„ ë”œë ˆì´
  
Enterprise_License:
  - ë¹„ë””ì˜¤ ì†ŒìŠ¤: ìµœëŒ€ 16ê°œ
  - Live API
  - NDI ì…ì¶œë ¥
  - ë‹¤ì¤‘ ë™ì‹œ ì¶œë ¥
```

---

## ğŸ¯ PokerGFX ì™„ì „ ë³µì œ ì „ëµ

### í•µì‹¬ êµ¬í˜„ ì›ì¹™

#### 1. RFID ì‹œìŠ¤í…œ ì™„ì „ ë³µì œ
```yaml
RFID_Reader_ëª¨ë“ˆ:
  í•˜ë“œì›¨ì–´_ì—°ë™:
    - USB 3.0 RFID Reader ì§€ì›
    - 52ì¥ ê°œë³„ ì¹´ë“œ ë“±ë¡ ì‹œìŠ¤í…œ
    - í…Œì´ë¸” ìº˜ë¦¬ë¸Œë ˆì´ì…˜ ê¸°ëŠ¥
    - ì•ˆí…Œë‚˜ ì‹ í˜¸ ê°•ë„ ëª¨ë‹ˆí„°ë§
    
  ì†Œí”„íŠ¸ì›¨ì–´_ê¸°ëŠ¥:
    - ì‹¤ì‹œê°„ ì¹´ë“œ ê°ì§€
    - í¬ì§€ì…˜ë³„ ì¹´ë“œ ì¸ì‹
    - ì¹´ë“œ ì¤‘ë³µ ê°ì§€ ë° ì˜¤ë¥˜ ì²˜ë¦¬
    - RFID ì‹ í˜¸ í’ˆì§ˆ ì²´í¬
```

#### 2. PokerGFX í˜¸í™˜ ì•„í‚¤í…ì²˜
```yaml
ì‹œìŠ¤í…œ_êµ¬ì¡°:
  - Windows ê¸°ë°˜ ë°ìŠ¤í¬í†± ì• í”Œë¦¬ì¼€ì´ì…˜
  - Action Tracker ë³„ë„ ì• í”Œë¦¬ì¼€ì´ì…˜
  - ë¡œì»¬ ë„¤íŠ¸ì›Œí¬ ê¸°ë°˜ í†µì‹ 
  - DirectX/OpenGL ê·¸ë˜í”½ ë Œë”ë§
  
ë¼ì´ì„ ìŠ¤_í‹°ì–´:
  - Basic: 4ê°œ ë¹„ë””ì˜¤ ì†ŒìŠ¤, 30ë¶„ ë”œë ˆì´
  - Pro: 8ê°œ ì†ŒìŠ¤, Studio ê¸°ëŠ¥, 60ë¶„ ë”œë ˆì´
  - Enterprise: 16ê°œ ì†ŒìŠ¤, API, NDI ì§€ì›
```

#### 3. ê¸°ì¡´ ì›Œí¬í”Œë¡œìš° ì™„ì „ ë³´ì¡´
```yaml
ì‚¬ìš©ì_ì›Œí¬í”Œë¡œìš°:
  - RFID í…Œì´ë¸” ìº˜ë¦¬ë¸Œë ˆì´ì…˜ ê³¼ì •
  - 52ì¥ ì¹´ë“œ ê°œë³„ ë“±ë¡
  - ë¹„ë””ì˜¤ ì†ŒìŠ¤ êµ¬ì„±
  - í”Œë ˆì´ì–´ í”„ë¡œí•„ ì„¤ì •
  - ë¼ì´ë¸Œ ë°©ì†¡ ë° ë…¹í™” ì‹œì‘
```

---

## ğŸ—ï¸ PokerGFX ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜

### ì „ì²´ êµ¬ì¡°ë„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  PokerGFX ì™„ì „ ë³µì œ ì‹œìŠ¤í…œ                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  ë°ìŠ¤í¬í†± ì•±     â”‚  í•˜ë“œì›¨ì–´ ì¸µ    â”‚      ì™¸ë¶€ ì—°ë™          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ â€¢ PokerGFX Serverâ”‚ â€¢ RFID Reader   â”‚ â€¢ OBS Studio ì—°ë™       â”‚
â”‚ â€¢ Action Tracker â”‚ â€¢ USB 3.0 í—ˆë¸Œ  â”‚ â€¢ Twitch/YouTube API    â”‚
â”‚ â€¢ Studio Editor  â”‚ â€¢ ë¹„ë””ì˜¤ ìº¡ì²˜   â”‚ â€¢ ATEM ìŠ¤ìœ„ì²˜ ì œì–´      â”‚
â”‚ â€¢ Graphics Engineâ”‚ â€¢ DirectX/OpenGLâ”‚ â€¢ NDI ì…ì¶œë ¥            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### í•µì‹¬ ì»´í¬ë„ŒíŠ¸

#### 1. PokerGFX Server (ë°ìŠ¤í¬í†± ì• í”Œë¦¬ì¼€ì´ì…˜)
```cpp
// C++/C# ê¸°ë°˜ ë©”ì¸ ì• í”Œë¦¬ì¼€ì´ì…˜ êµ¬ì¡°
class PokerGFXServer {
public:
    PokerGFXServer() {
        rfidReader = new RFIDReaderController();
        gameState = new GameStateManager();
        videoSources = new VideoSourceManager();
        graphics = new DirectXRenderer();
        streaming = new StreamManager();
        actionTracker = new ActionTrackerServer();
    }
    
    bool InitializeSystem() {
        // 1. RFID Reader ì´ˆê¸°í™”
        if (!rfidReader->Connect()) {
            ShowError("RFID Reader ì—°ê²° ì‹¤íŒ¨");
            return false;
        }
        
        // 2. ë¹„ë””ì˜¤ ìº¡ì²˜ ì¥ë¹„ ê²€ìƒ‰
        videoSources->DetectCaptureDevices();
        
        // 3. DirectX ê·¸ë˜í”½ ì—”ì§„ ì´ˆê¸°í™”
        graphics->Initialize(GetHWND());
        
        // 4. ë„¤íŠ¸ì›Œí¬ ì„œë²„ ì‹œì‘ (Action Trackerìš©)
        actionTracker->StartServer(DEFAULT_PORT);
        
        return true;
    }
    
    void StartCalibration() {
        // PokerGFX ìŠ¤íƒ€ì¼ í…Œì´ë¸” ìº˜ë¦¬ë¸Œë ˆì´ì…˜
        CalibrationWizard wizard;
        wizard.ShowModal();
        
        // ê° ì¢Œì„ ìœ„ì¹˜ ì„¤ì •
        for (int i = 0; i < MAX_PLAYERS; i++) {
            PlayerPosition pos = wizard.GetPlayerPosition(i);
            rfidReader->SetPlayerAntenna(i, pos);
        }
    }
    
private:
    RFIDReaderController* rfidReader;
    GameStateManager* gameState;
    VideoSourceManager* videoSources;
    DirectXRenderer* graphics;
    StreamManager* streaming;
    ActionTrackerServer* actionTracker;
};
```

#### 2. Action Tracker (ë³„ë„ ë°ìŠ¤í¬í†± ì•±)
```cpp
// Windows Forms ê¸°ë°˜ Action Tracker ì• í”Œë¦¬ì¼€ì´ì…˜
class ActionTrackerApp : public Form {
public:
    ActionTrackerApp() {
        InitializeComponent();
        tcpClient = new TcpClient();
        ConnectToMainServer();
    }
    
    void ConnectToMainServer() {
        try {
            tcpClient->Connect("localhost", POKERGFX_PORT);
            networkStream = tcpClient->GetStream();
            StartMessageListener();
        }
        catch (Exception^ ex) {
            MessageBox::Show("PokerGFX Server ì—°ê²° ì‹¤íŒ¨: " + ex->Message);
        }
    }
  
  renderPlayerActions(players) {
    return players.map(player => ({
      name: player.name,
      stack: player.stack,
      quickActions: ['fold', 'call', 'raise'],
      customBetInput: true
    }));
  }
  
  async submitAction(playerId, action, amount = 0) {
    const actionData = {
      playerId,
      action,
      amount,
      timestamp: Date.now()
    };
    
    // ì‹¤ì‹œê°„ìœ¼ë¡œ ë©”ì¸ ì• í”Œë¦¬ì¼€ì´ì…˜ì— ì „ì†¡
    this.socket.send(JSON.stringify(actionData));
    
    // ë¡œì»¬ UI ì—…ë°ì´íŠ¸
    this.ui.updatePlayerStatus(playerId, action);
  }
}
```

#### 3. ê²Œì„ ìƒíƒœ ê´€ë¦¬ì
```javascript
class GameStateManager {
  constructor() {
    this.players = new Map();
    this.currentHand = null;
    this.pot = 0;
    this.communityCards = [];
    this.actionHistory = [];
    this.bettingRound = 'preflop';
  }
  
  // PokerGFXì™€ ë™ì¼í•œ ê²Œì„ ë¡œì§ êµ¬í˜„
  processAction(playerId, action, amount) {
    const player = this.players.get(playerId);
    
    switch(action) {
      case 'fold':
        player.status = 'folded';
        player.cards = null; // ë³´ì•ˆì„ ìœ„í•´ ì¹´ë“œ ìˆ¨ê¹€
        break;
        
      case 'call':
        const callAmount = this.getCurrentBet() - player.currentBet;
        player.stack -= callAmount;
        this.pot += callAmount;
        break;
        
      case 'raise':
        const raiseAmount = amount - player.currentBet;
        player.stack -= raiseAmount;
        this.pot += raiseAmount;
        this.currentBet = amount;
        break;
    }
    
    this.actionHistory.push({
      playerId,
      action,
      amount,
      timestamp: Date.now()
    });
    
    // ë² íŒ… ë¼ìš´ë“œ ì§„í–‰ ì²´í¬
    this.checkBettingRoundComplete();
  }
  
  checkBettingRoundComplete() {
    const activePlayers = Array.from(this.players.values())
      .filter(p => p.status === 'active');
      
    const allActionsComplete = activePlayers.every(p => 
      p.hasActed && p.currentBet === this.currentBet
    );
    
    if (allActionsComplete) {
      this.advanceBettingRound();
    }
  }
}
```

---

## ğŸ¨ ì‚¬ìš©ì ì¸í„°í˜ì´ìŠ¤ ì„¤ê³„

### 1. ë©”ì¸ ì»¨íŠ¸ë¡¤ í™”ë©´

```html
<!DOCTYPE html>
<html>
<head>
    <title>Poker-GFX Control Center</title>
    <style>
        .control-panel {
            display: grid;
            grid-template-areas: 
                "video-preview game-info"
                "player-list stream-status"
                "action-controls system-status";
            gap: 20px;
            padding: 20px;
        }
        
        .video-preview {
            grid-area: video-preview;
            background: #000;
            border-radius: 8px;
            position: relative;
        }
        
        .overlay-graphics {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div class="control-panel">
        <!-- ë¹„ë””ì˜¤ í”„ë¦¬ë·° ì˜ì—­ -->
        <div class="video-preview">
            <video id="mainVideo" autoplay muted></video>
            <canvas class="overlay-graphics" id="gameOverlay"></canvas>
            
            <!-- ì¹´ë©”ë¼ ì „í™˜ ë²„íŠ¼ -->
            <div class="camera-controls">
                <button onclick="switchCamera(1)">Cam 1</button>
                <button onclick="switchCamera(2)">Cam 2</button>
                <button onclick="switchCamera(3)">Cam 3</button>
                <button onclick="enableAutoSwitch()">Auto</button>
            </div>
        </div>
        
        <!-- ê²Œì„ ì •ë³´ íŒ¨ë„ -->
        <div class="game-info">
            <h3>Game Status</h3>
            <div>Hand #: <span id="handNumber">1</span></div>
            <div>Pot: $<span id="potSize">0</span></div>
            <div>Stakes: <span id="stakes">1/2</span></div>
            <div>Round: <span id="bettingRound">Pre-flop</span></div>
        </div>
        
        <!-- í”Œë ˆì´ì–´ ëª©ë¡ -->
        <div class="player-list">
            <h3>Players</h3>
            <div id="playersList">
                <!-- ë™ì ìœ¼ë¡œ ìƒì„±ë¨ -->
            </div>
        </div>
        
        <!-- ìŠ¤íŠ¸ë¦¬ë° ìƒíƒœ -->
        <div class="stream-status">
            <h3>Streaming</h3>
            <div class="stream-item">
                <span>Twitch:</span>
                <span class="status connected">Connected</span>
                <span>856 viewers</span>
            </div>
            <div class="stream-item">
                <span>YouTube:</span>  
                <span class="status connecting">Connecting...</span>
            </div>
        </div>
    </div>
</body>
</html>
```

### 2. Action Tracker ëª¨ë°”ì¼ ì¸í„°í˜ì´ìŠ¤

```html
<!DOCTYPE html>
<html>
<head>
    <title>Poker Action Tracker</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        .action-tracker {
            display: flex;
            flex-direction: column;
            height: 100vh;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto;
        }
        
        .game-header {
            background: #2c3e50;
            color: white;
            padding: 15px;
            text-align: center;
        }
        
        .players-grid {
            flex: 1;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            padding: 10px;
            overflow-y: auto;
        }
        
        .player-card {
            background: white;
            border-radius: 12px;
            padding: 15px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            border: 2px solid transparent;
        }
        
        .player-card.active {
            border-color: #3498db;
        }
        
        .player-card.folded {
            opacity: 0.5;
            background: #ecf0f1;
        }
        
        .player-name {
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .player-stack {
            color: #27ae60;
            font-size: 14px;
            margin-bottom: 10px;
        }
        
        .action-buttons {
            display: flex;
            gap: 5px;
        }
        
        .action-btn {
            flex: 1;
            padding: 8px 12px;
            border: none;
            border-radius: 6px;
            font-size: 12px;
            font-weight: bold;
            cursor: pointer;
        }
        
        .fold-btn { background: #e74c3c; color: white; }
        .call-btn { background: #f39c12; color: white; }
        .raise-btn { background: #e67e22; color: white; }
        
        .pot-info {
            background: #34495e;
            color: white;
            padding: 20px;
            text-align: center;
            font-size: 18px;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="action-tracker">
        <div class="game-header">
            <div>Hand #<span id="handNum">47</span> | Pot: $<span id="potAmount">2,850</span></div>
            <div style="font-size: 14px; opacity: 0.8">Pre-flop | Stakes: $5/$10</div>
        </div>
        
        <div class="players-grid" id="playersGrid">
            <!-- í”Œë ˆì´ì–´ ì¹´ë“œë“¤ì´ ì—¬ê¸°ì— ë™ì ìœ¼ë¡œ ìƒì„±ë¨ -->
        </div>
        
        <div class="pot-info">
            Current Pot: $<span id="currentPot">2,850</span>
        </div>
    </div>
    
    <script>
        // í”Œë ˆì´ì–´ ì•¡ì…˜ ì²˜ë¦¬ JavaScript
        class ActionTrackerUI {
            constructor() {
                this.socket = new WebSocket('ws://localhost:3001');
                this.players = [];
                this.initializeUI();
            }
            
            initializeUI() {
                this.socket.onmessage = (event) => {
                    const data = JSON.parse(event.data);
                    this.updateGameState(data);
                };
            }
            
            renderPlayers(players) {
                const grid = document.getElementById('playersGrid');
                grid.innerHTML = '';
                
                players.forEach(player => {
                    const card = document.createElement('div');
                    card.className = `player-card ${player.status}`;
                    card.innerHTML = `
                        <div class="player-name">${player.name}</div>
                        <div class="player-stack">$${player.stack}</div>
                        <div class="action-buttons">
                            <button class="action-btn fold-btn" 
                                onclick="submitAction('${player.id}', 'fold')">Fold</button>
                            <button class="action-btn call-btn" 
                                onclick="submitAction('${player.id}', 'call')">Call</button>
                            <button class="action-btn raise-btn" 
                                onclick="showRaiseDialog('${player.id}')">Raise</button>
                        </div>
                    `;
                    grid.appendChild(card);
                });
            }
            
            submitAction(playerId, action, amount = 0) {
                const actionData = {
                    type: 'player_action',
                    playerId,
                    action,
                    amount,
                    timestamp: Date.now()
                };
                
                this.socket.send(JSON.stringify(actionData));
                
                // ì‹œê°ì  í”¼ë“œë°±
                this.showActionFeedback(playerId, action);
            }
            
            showActionFeedback(playerId, action) {
                // ì•¡ì…˜ ì‹¤í–‰ ì‹œ ì‹œê°ì  í”¼ë“œë°± í‘œì‹œ
                const playerCard = document.querySelector(`[data-player="${playerId}"]`);
                playerCard.classList.add('action-submitted');
                
                setTimeout(() => {
                    playerCard.classList.remove('action-submitted');
                }, 1000);
            }
        }
        
        // ì•± ì´ˆê¸°í™”
        const actionTracker = new ActionTrackerUI();
    </script>
</body>
</html>
```

---

## ğŸ® í•µì‹¬ ê¸°ëŠ¥ êµ¬í˜„

### 1. ì¹´ë“œ ì…ë ¥ ì‹œìŠ¤í…œ

```javascript
// RFIDë¥¼ ëŒ€ì²´í•˜ëŠ” ì§ê´€ì ì¸ ì¹´ë“œ ì…ë ¥ ì‹œìŠ¤í…œ
class CardInputSystem {
  constructor() {
    this.currentPlayer = null;
    this.cardSelection = new CardSelector();
    this.gameState = null;
  }
  
  // í™€ì¹´ë“œ ì…ë ¥ ëª¨ë“œ
  startHolecardInput(playerId) {
    this.currentPlayer = playerId;
    this.cardSelection.show({
      title: `Enter hole cards for ${this.getPlayerName(playerId)}`,
      cardsNeeded: 2,
      onComplete: (cards) => this.setPlayerHolecards(playerId, cards)
    });
  }
  
  // ì»¤ë®¤ë‹ˆí‹° ì¹´ë“œ ì…ë ¥
  addCommunityCard() {
    const existingCards = this.gameState.communityCards;
    
    this.cardSelection.show({
      title: `Add community card (${existingCards.length + 1}/5)`,
      cardsNeeded: 1,
      excludeCards: [...existingCards, ...this.getAllPlayerCards()],
      onComplete: (cards) => this.addToCommunity(cards[0])
    });
  }
  
  // ë¹ ë¥¸ ì…ë ¥ì„ ìœ„í•œ í‚¤ë³´ë“œ ë‹¨ì¶•í‚¤
  setupKeyboardShortcuts() {
    document.addEventListener('keydown', (event) => {
      // ìˆ«ì í‚¤ë¡œ í”Œë ˆì´ì–´ ì„ íƒ (1-9)
      if (event.key >= '1' && event.key <= '9') {
        const playerIndex = parseInt(event.key) - 1;
        this.selectPlayer(playerIndex);
      }
      
      // ì¹´ë“œ ì…ë ¥ ë‹¨ì¶•í‚¤ (ì˜ˆ: "AS" = Ace of Spades)
      if (event.key === 'h') this.startHolecardInput(this.currentPlayer);
      if (event.key === 'f') this.dealFlop();
      if (event.key === 't') this.dealTurn();
      if (event.key === 'r') this.dealRiver();
    });
  }
}

// ì¹´ë“œ ì„ íƒ UI ì»´í¬ë„ŒíŠ¸
class CardSelector {
  constructor() {
    this.element = this.createElement();
    this.selectedCards = [];
    this.onComplete = null;
  }
  
  createElement() {
    const container = document.createElement('div');
    container.className = 'card-selector-overlay';
    container.innerHTML = `
      <div class="card-selector">
        <h3 class="selector-title"></h3>
        <div class="card-grid">
          ${this.renderCardGrid()}
        </div>
        <div class="selected-cards">
          <h4>Selected Cards:</h4>
          <div class="selected-display"></div>
        </div>
        <div class="selector-buttons">
          <button class="cancel-btn">Cancel</button>
          <button class="confirm-btn" disabled>Confirm</button>
        </div>
      </div>
    `;
    
    this.setupEventListeners(container);
    return container;
  }
  
  renderCardGrid() {
    const suits = ['â™ ', 'â™¥', 'â™¦', 'â™£'];
    const ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', 'T', 'J', 'Q', 'K'];
    
    let html = '';
    suits.forEach(suit => {
      ranks.forEach(rank => {
        const cardId = rank + suit;
        html += `
          <div class="card-option" data-card="${cardId}">
            <span class="card-rank">${rank}</span>
            <span class="card-suit ${suit === 'â™¥' || suit === 'â™¦' ? 'red' : 'black'}">${suit}</span>
          </div>
        `;
      });
    });
    
    return html;
  }
  
  show(options) {
    this.selectedCards = [];
    this.cardsNeeded = options.cardsNeeded;
    this.onComplete = options.onComplete;
    this.excludeCards = options.excludeCards || [];
    
    // ì œëª© ì„¤ì •
    this.element.querySelector('.selector-title').textContent = options.title;
    
    // ì œì™¸í•  ì¹´ë“œë“¤ ë¹„í™œì„±í™”
    this.excludeCards.forEach(card => {
      const cardElement = this.element.querySelector(`[data-card="${card}"]`);
      if (cardElement) {
        cardElement.classList.add('disabled');
      }
    });
    
    // ëª¨ë‹¬ í‘œì‹œ
    document.body.appendChild(this.element);
    this.element.style.display = 'flex';
  }
  
  selectCard(cardId) {
    if (this.excludeCards.includes(cardId)) return;
    if (this.selectedCards.includes(cardId)) return;
    if (this.selectedCards.length >= this.cardsNeeded) return;
    
    this.selectedCards.push(cardId);
    this.updateSelectedDisplay();
    this.updateConfirmButton();
    
    // ì‹œê°ì  í”¼ë“œë°±
    const cardElement = this.element.querySelector(`[data-card="${cardId}"]`);
    cardElement.classList.add('selected');
  }
  
  updateSelectedDisplay() {
    const display = this.element.querySelector('.selected-display');
    display.innerHTML = this.selectedCards.map(card => 
      `<span class="selected-card">${card}</span>`
    ).join('');
  }
  
  updateConfirmButton() {
    const confirmBtn = this.element.querySelector('.confirm-btn');
    confirmBtn.disabled = this.selectedCards.length !== this.cardsNeeded;
  }
  
  confirm() {
    if (this.selectedCards.length === this.cardsNeeded && this.onComplete) {
      this.onComplete(this.selectedCards);
    }
    this.hide();
  }
  
  hide() {
    this.element.style.display = 'none';
    if (this.element.parentNode) {
      this.element.parentNode.removeChild(this.element);
    }
  }
}
```

### 2. ì‹¤ì‹œê°„ ê·¸ë˜í”½ ì˜¤ë²„ë ˆì´

```javascript
class GraphicsRenderer {
  constructor(canvasId) {
    this.canvas = document.getElementById(canvasId);
    this.ctx = this.canvas.getContext('2d');
    this.theme = new GraphicsTheme();
    this.animations = new AnimationEngine();
    
    // ìº”ë²„ìŠ¤ í¬ê¸°ë¥¼ ë¹„ë””ì˜¤ì— ë§ì¶¤
    this.resizeCanvas();
    window.addEventListener('resize', () => this.resizeCanvas());
  }
  
  // PokerGFX ìŠ¤íƒ€ì¼ì˜ ê·¸ë˜í”½ ë Œë”ë§
  render(gameState) {
    // ìº”ë²„ìŠ¤ í´ë¦¬ì–´
    this.clearCanvas();
    
    // í”Œë ˆì´ì–´ ì •ë³´ ë Œë”ë§
    this.renderPlayers(gameState.players);
    
    // ì»¤ë®¤ë‹ˆí‹° ì¹´ë“œ ë Œë”ë§  
    this.renderCommunityCards(gameState.communityCards, gameState.bettingRound);
    
    // íŒŸ ì •ë³´ ë Œë”ë§
    this.renderPotInfo(gameState.pot, gameState.sidePots);
    
    // ë² íŒ… ì•¡ì…˜ í•˜ì´ë¼ì´íŠ¸
    this.renderActionHighlights(gameState.recentActions);
    
    // ë”œëŸ¬ ë²„íŠ¼ ìœ„ì¹˜
    this.renderDealerButton(gameState.dealerPosition);
    
    // ì• ë‹ˆë©”ì´ì…˜ ì—…ë°ì´íŠ¸
    this.animations.update();
  }
  
  renderPlayers(players) {
    players.forEach((player, index) => {
      const position = this.getPlayerPosition(index, players.length);
      
      // í”Œë ˆì´ì–´ ë°°ê²½ ë°•ìŠ¤
      this.drawPlayerBackground(position, player.status);
      
      // í”Œë ˆì´ì–´ ì´ë¦„
      this.drawText(player.name, {
        x: position.x,
        y: position.y - 30,
        font: this.theme.playerNameFont,
        color: this.theme.playerNameColor,
        align: 'center'
      });
      
      // ì¹© ìŠ¤íƒ
      this.drawText(`$${player.stack}`, {
        x: position.x,
        y: position.y - 10,
        font: this.theme.stackFont,
        color: this.theme.stackColor,
        align: 'center'
      });
      
      // í™€ì¹´ë“œ (ê³µê°œëœ ê²½ìš°)
      if (player.holecards && this.shouldShowCards(player)) {
        this.drawCards(player.holecards, {
          x: position.x - 35,
          y: position.y + 10
        });
      }
      
      // í˜„ì¬ ë² íŒ… ì•¡ì…˜
      if (player.currentAction) {
        this.drawActionIndicator(player.currentAction, position);
      }
      
      // ë² íŒ… ì¹© ì• ë‹ˆë©”ì´ì…˜
      if (player.currentBet > 0) {
        this.drawBettingChips(player.currentBet, position);
      }
    });
  }
  
  renderCommunityCards(cards, bettingRound) {
    const centerX = this.canvas.width / 2;
    const centerY = this.canvas.height / 2;
    
    // ì»¤ë®¤ë‹ˆí‹° ì¹´ë“œ ë°°ê²½
    this.drawRoundedRect({
      x: centerX - 150,
      y: centerY - 40,
      width: 300,
      height: 80,
      radius: 10,
      fill: this.theme.communityCardBackground
    });
    
    // ì¹´ë“œë“¤ ë Œë”ë§
    cards.forEach((card, index) => {
      const x = centerX - 125 + (index * 50);
      const y = centerY - 30;
      
      this.drawCard(card, { x, y });
      
      // ì¹´ë“œ ê³µê°œ ì• ë‹ˆë©”ì´ì…˜
      if (this.isNewlyRevealedCard(card, bettingRound)) {
        this.animations.add(new CardRevealAnimation(card, { x, y }));
      }
    });
    
    // ë‹¤ìŒ ì¹´ë“œ ìë¦¬ í‘œì‹œ
    const nextCardIndex = cards.length;
    if (nextCardIndex < 5) {
      const x = centerX - 125 + (nextCardIndex * 50);
      const y = centerY - 30;
      this.drawCardPlaceholder({ x, y });
    }
  }
  
  renderPotInfo(mainPot, sidePots = []) {
    const centerX = this.canvas.width / 2;
    const potY = 100;
    
    // ë©”ì¸ íŒŸ
    this.drawText(`Pot: $${mainPot}`, {
      x: centerX,
      y: potY,
      font: this.theme.potFont,
      color: this.theme.potColor,
      align: 'center',
      shadow: true
    });
    
    // ì‚¬ì´ë“œ íŒŸë“¤
    sidePots.forEach((pot, index) => {
      this.drawText(`Side Pot ${index + 1}: $${pot.amount}`, {
        x: centerX,
        y: potY + 30 + (index * 25),
        font: this.theme.sidePotFont,
        color: this.theme.sidePotColor,
        align: 'center'
      });
    });
  }
  
  // PokerGFX ìŠ¤íƒ€ì¼ì˜ ì¹´ë“œ ë Œë”ë§
  drawCard(card, position) {
    const { rank, suit } = this.parseCard(card);
    const isRed = suit === 'â™¥' || suit === 'â™¦';
    
    // ì¹´ë“œ ë°°ê²½
    this.drawRoundedRect({
      x: position.x,
      y: position.y,
      width: 40,
      height: 60,
      radius: 5,
      fill: '#ffffff',
      stroke: '#cccccc',
      strokeWidth: 2
    });
    
    // ë­í¬
    this.drawText(rank, {
      x: position.x + 8,
      y: position.y + 15,
      font: '14px Arial Bold',
      color: isRed ? '#d32f2f' : '#000000'
    });
    
    // ìˆ˜íŠ¸
    this.drawText(suit, {
      x: position.x + 8,
      y: position.y + 35,
      font: '16px Arial',
      color: isRed ? '#d32f2f' : '#000000'
    });
    
    // ë’·ë©´ ë­í¬/ìˆ˜íŠ¸ (ìš°í•˜ë‹¨)
    this.drawText(rank, {
      x: position.x + 32,
      y: position.y + 45,
      font: '10px Arial Bold',
      color: isRed ? '#d32f2f' : '#000000',
      rotate: 180
    });
    
    this.drawText(suit, {
      x: position.x + 32,
      y: position.y + 25,
      font: '12px Arial',
      color: isRed ? '#d32f2f' : '#000000',
      rotate: 180
    });
  }
  
  // ë² íŒ… ì•¡ì…˜ ì• ë‹ˆë©”ì´ì…˜
  drawActionIndicator(action, position) {
    const colors = {
      fold: '#f44336',
      call: '#ff9800', 
      raise: '#4caf50',
      check: '#2196f3',
      allin: '#9c27b0'
    };
    
    // ì•¡ì…˜ ë²„ë¸”
    this.drawRoundedRect({
      x: position.x - 25,
      y: position.y - 60,
      width: 50,
      height: 20,
      radius: 10,
      fill: colors[action.type] || '#666666'
    });
    
    // ì•¡ì…˜ í…ìŠ¤íŠ¸
    this.drawText(action.type.toUpperCase(), {
      x: position.x,
      y: position.y - 45,
      font: '10px Arial Bold',
      color: '#ffffff',
      align: 'center'
    });
    
    // ë² íŒ… ê¸ˆì•¡ (ìˆëŠ” ê²½ìš°)
    if (action.amount > 0) {
      this.drawText(`$${action.amount}`, {
        x: position.x,
        y: position.y - 30,
        font: '12px Arial Bold',  
        color: colors[action.type],
        align: 'center'
      });
    }
  }
  
  // í”Œë ˆì´ì–´ í¬ì§€ì…˜ ê³„ì‚° (ì›í˜• ë°°ì¹˜)
  getPlayerPosition(index, totalPlayers) {
    const centerX = this.canvas.width / 2;
    const centerY = this.canvas.height / 2;
    const radius = Math.min(centerX, centerY) * 0.7;
    
    // ë²„íŠ¼ì´ 6ì‹œ ë°©í–¥ì— ì˜¤ë„ë¡ ê°ë„ ì¡°ì •
    const angle = (2 * Math.PI * index / totalPlayers) - (Math.PI / 2);
    
    return {
      x: centerX + radius * Math.cos(angle),
      y: centerY + radius * Math.sin(angle)
    };
  }
}

// ê·¸ë˜í”½ í…Œë§ˆ ì‹œìŠ¤í…œ
class GraphicsTheme {
  constructor(themeName = 'default') {
    this.themes = {
      default: {
        background: '#0d4f2c',
        playerNameFont: '14px Arial Bold',
        playerNameColor: '#ffffff',
        stackFont: '12px Arial',
        stackColor: '#ffd700',
        potFont: '24px Arial Bold',
        potColor: '#ffffff',
        communityCardBackground: 'rgba(0,0,0,0.5)',
        actionColors: {
          fold: '#f44336',
          call: '#ff9800',
          raise: '#4caf50'
        }
      },
      
      modern: {
        background: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
        playerNameFont: '14px "Segoe UI" Bold',
        playerNameColor: '#ffffff',
        stackFont: '12px "Segoe UI"',
        stackColor: '#00d4aa',
        potFont: '24px "Segoe UI" Bold',
        potColor: '#ffffff'
      },
      
      casino: {
        background: '#1a1a1a',
        playerNameFont: '14px "Times New Roman" Bold',
        playerNameColor: '#ffd700',
        stackFont: '12px "Times New Roman"',
        stackColor: '#ffffff',
        potFont: '24px "Times New Roman" Bold',
        potColor: '#ffd700'
      }
    };
    
    this.currentTheme = this.themes[themeName];
  }
  
  setTheme(themeName) {
    if (this.themes[themeName]) {
      this.currentTheme = this.themes[themeName];
    }
  }
  
  get(property) {
    return this.currentTheme[property];
  }
}
```

### 3. ìŠ¤íŠ¸ë¦¬ë° ì—°ë™ ì‹œìŠ¤í…œ

```javascript
// OBS Studio WebSocket ì—°ë™
class OBSController {
  constructor() {
    this.obs = null;
    this.connected = false;
    this.scenes = [];
    this.sources = [];
  }
  
  async connect(address = 'localhost:4444', password = '') {
    try {
      // OBS WebSocket ë¼ì´ë¸ŒëŸ¬ë¦¬ ì‚¬ìš©
      this.obs = new OBSWebSocket();
      
      await this.obs.connect({
        address: address,
        password: password
      });
      
      this.connected = true;
      this.setupEventListeners();
      
      // í˜„ì¬ ì”¬ê³¼ ì†ŒìŠ¤ ì •ë³´ ê°€ì ¸ì˜¤ê¸°
      await this.refreshSceneList();
      
      return true;
    } catch (error) {
      console.error('OBS ì—°ê²° ì‹¤íŒ¨:', error);
      return false;
    }
  }
  
  setupEventListeners() {
    this.obs.on('SwitchScenes', (data) => {
      console.log('ì”¬ ë³€ê²½ë¨:', data.sceneName);
    });
    
    this.obs.on('StreamStarted', () => {
      console.log('ìŠ¤íŠ¸ë¦¬ë° ì‹œì‘ë¨');
    });
    
    this.obs.on('StreamStopped', () => {
      console.log('ìŠ¤íŠ¸ë¦¬ë° ì¤‘ì§€ë¨');
    });
  }
  
  async refreshSceneList() {
    try {
      const result = await this.obs.send('GetSceneList');
      this.scenes = result.scenes;
      return this.scenes;
    } catch (error) {
      console.error('ì”¬ ëª©ë¡ ê°€ì ¸ì˜¤ê¸° ì‹¤íŒ¨:', error);
      return [];
    }
  }
  
  // ë¸Œë¼ìš°ì € ì†ŒìŠ¤ì— ê²Œì„ ì˜¤ë²„ë ˆì´ ì—…ë°ì´íŠ¸
  async updateGameOverlay(gameState) {
    try {
      // ë¸Œë¼ìš°ì € ì†ŒìŠ¤ ì°¾ê¸°
      const browserSource = await this.findBrowserSource('Poker Overlay');
      
      if (browserSource) {
        // JavaScriptë¥¼ í†µí•´ ì˜¤ë²„ë ˆì´ ì—…ë°ì´íŠ¸
        const script = `
          if (window.updateGameState) {
            window.updateGameState(${JSON.stringify(gameState)});
          }
        `;
        
        await this.obs.send('ExecuteJavaScript', {
          sourceName: browserSource.name,
          script: script
        });
      }
    } catch (error) {
      console.error('ì˜¤ë²„ë ˆì´ ì—…ë°ì´íŠ¸ ì‹¤íŒ¨:', error);
    }
  }
  
  async findBrowserSource(sourceName) {
    try {
      const sources = await this.obs.send('GetSourcesList');
      return sources.sources.find(source => 
        source.name === sourceName && source.typeId === 'browser_source'
      );
    } catch (error) {
      return null;
    }
  }
  
  // ìë™ ì”¬ ì „í™˜ (ê²Œì„ ìƒí™©ì— ë”°ë¼)
  async autoSwitchScene(gameState) {
    let targetScene = 'Table Overview';
    
    // ê²Œì„ ìƒí™©ì— ë”°ë¥¸ ì”¬ ì„ íƒ ë¡œì§
    if (gameState.bettingRound === 'showdown') {
      targetScene = 'Showdown';
    } else if (gameState.playersInHand <= 2) {
      targetScene = 'Heads Up';
    } else if (gameState.recentAction?.type === 'allin') {
      targetScene = 'All-in Drama';
    }
    
    try {
      await this.obs.send('SetCurrentScene', {
        'scene-name': targetScene
      });
    } catch (error) {
      console.error('ì”¬ ì „í™˜ ì‹¤íŒ¨:', error);
    }
  }
  
  // ìŠ¤íŠ¸ë¦¬ë° ì‹œì‘/ì¤‘ì§€
  async startStreaming() {
    try {
      await this.obs.send('StartStreaming');
      return true;
    } catch (error) {
      console.error('ìŠ¤íŠ¸ë¦¬ë° ì‹œì‘ ì‹¤íŒ¨:', error);
      return false;
    }
  }
  
  async stopStreaming() {
    try {
      await this.obs.send('StopStreaming');
      return true;
    } catch (error) {
      console.error('ìŠ¤íŠ¸ë¦¬ë° ì¤‘ì§€ ì‹¤íŒ¨:', error);
      return false;
    }
  }
  
  // ë…¹í™” ì‹œì‘/ì¤‘ì§€
  async startRecording() {
    try {
      await this.obs.send('StartRecording');
      return true;
    } catch (error) {
      console.error('ë…¹í™” ì‹œì‘ ì‹¤íŒ¨:', error);
      return false;
    }
  }
  
  async stopRecording() {
    try {
      await this.obs.send('StopRecording');
      return true;
    } catch (error) {
      console.error('ë…¹í™” ì¤‘ì§€ ì‹¤íŒ¨:', error);
      return false;
    }
  }
}

// Twitch API ì—°ë™
class TwitchIntegration {
  constructor(clientId, accessToken) {
    this.clientId = clientId;
    this.accessToken = accessToken;
    this.apiBase = 'https://api.twitch.tv/helix';
  }
  
  async getStreamInfo() {
    try {
      const response = await fetch(`${this.apiBase}/streams`, {
        headers: {
          'Client-ID': this.clientId,
          'Authorization': `Bearer ${this.accessToken}`
        }
      });
      
      const data = await response.json();
      return data.data[0]; // í˜„ì¬ ìŠ¤íŠ¸ë¦¼ ì •ë³´
    } catch (error) {
      console.error('Twitch ìŠ¤íŠ¸ë¦¼ ì •ë³´ ê°€ì ¸ì˜¤ê¸° ì‹¤íŒ¨:', error);
      return null;
    }
  }
  
  async updateStreamTitle(title) {
    try {
      const response = await fetch(`${this.apiBase}/channels`, {
        method: 'PATCH',
        headers: {
          'Client-ID': this.clientId,
          'Authorization': `Bearer ${this.accessToken}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          title: title
        })
      });
      
      return response.ok;
    } catch (error) {
      console.error('Twitch ìŠ¤íŠ¸ë¦¼ ì œëª© ì—…ë°ì´íŠ¸ ì‹¤íŒ¨:', error);
      return false;
    }
  }
  
  async createStreamMarker(description) {
    try {
      const response = await fetch(`${this.apiBase}/streams/markers`, {
        method: 'POST',
        headers: {
          'Client-ID': this.clientId,
          'Authorization': `Bearer ${this.accessToken}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          description: description
        })
      });
      
      return response.ok;
    } catch (error) {
      console.error('Twitch ë§ˆì»¤ ìƒì„± ì‹¤íŒ¨:', error);
      return false;
    }
  }
}
```

---

## ğŸ“± ë°°í¬ ë° ì‚¬ìš©ë²•

### 1. ì‹œìŠ¤í…œ ìš”êµ¬ì‚¬í•­

```yaml
ìµœì†Œ_ìš”êµ¬ì‚¬í•­:
  ìš´ì˜ì²´ì œ: Windows 10, macOS 10.14, Ubuntu 18.04
  CPU: Intel i5-8400 ë˜ëŠ” AMD Ryzen 5 2600
  RAM: 8GB
  GPU: í†µí•© ê·¸ë˜í”½ (Intel UHD 630 ì´ìƒ)
  ë„¤íŠ¸ì›Œí¬: ì—…ë¡œë“œ 5Mbps
  
ê¶Œì¥_ìš”êµ¬ì‚¬í•­:
  ìš´ì˜ì²´ì œ: Windows 11, macOS 12, Ubuntu 20.04
  CPU: Intel i7-10700K ë˜ëŠ” AMD Ryzen 7 3700X  
  RAM: 16GB
  GPU: NVIDIA GTX 1660 ë˜ëŠ” AMD RX 580
  ë„¤íŠ¸ì›Œí¬: ì—…ë¡œë“œ 25Mbps
```

### 2. ì„¤ì¹˜ ë° ì„¤ì • ê°€ì´ë“œ

#### ì›¹ ì„œë²„ ì‹¤í–‰
```bash
# 1. ì €ì¥ì†Œ í´ë¡ 
git clone https://github.com/yourname/poker-gfx.git
cd poker-gfx

# 2. ì˜ì¡´ì„± ì„¤ì¹˜
npm install

# 3. ì„œë²„ ì‹œì‘
npm start

# 4. ë¸Œë¼ìš°ì €ì—ì„œ ì ‘ì†
# http://localhost:3000
```

#### OBS Studio ì—°ë™ ì„¤ì •
```yaml
OBS_ì„¤ì •:
  1. OBS Studio ì„¤ì¹˜ (v28.0 ì´ìƒ)
  2. WebSocket í”ŒëŸ¬ê·¸ì¸ ì„¤ì¹˜
  3. Tools â†’ WebSocket Server Settings
  4. Enable WebSocket server ì²´í¬
  5. Server Port: 4444 (ê¸°ë³¸ê°’)
  6. ë¹„ë°€ë²ˆí˜¸ ì„¤ì • (ì„ íƒì‚¬í•­)
  
ë¸Œë¼ìš°ì €_ì†ŒìŠ¤_ì¶”ê°€:
  1. Sources â†’ Add â†’ Browser Source
  2. Name: "Poker Overlay"
  3. URL: http://localhost:3000/overlay
  4. Width: 1920, Height: 1080
  5. Custom CSS: (ì œê³µëœ CSS ì‚¬ìš©)
```

### 3. ì‚¬ìš© ì›Œí¬í”Œë¡œìš°

#### ê¸°ë³¸ ì‚¬ìš©ë²• (5ë¶„ ì„¤ì •)
```yaml
ë‹¨ê³„1_ì´ˆê¸°ì„¤ì •:
  - ì›¹ ë¸Œë¼ìš°ì €ì—ì„œ http://localhost:3000 ì ‘ì†
  - ê²Œì„ ì„¤ì • (Hold'em, ìŠ¤í…Œì´í¬, í”Œë ˆì´ì–´ ìˆ˜)
  - í”Œë ˆì´ì–´ ì´ë¦„ ì…ë ¥
  
ë‹¨ê³„2_OBSì—°ë™:
  - OBSì—ì„œ ë¸Œë¼ìš°ì € ì†ŒìŠ¤ ì¶”ê°€
  - ì˜¤ë²„ë ˆì´ URL ì„¤ì •
  - ì”¬ êµ¬ì„±
  
ë‹¨ê³„3_ê²Œì„ì‹œì‘:
  - Action Tracker ì—´ê¸° (ëª¨ë°”ì¼ ë˜ëŠ” ë³„ë„ ë¸Œë¼ìš°ì €)
  - ì²« í•¸ë“œ ì‹œì‘
  - í™€ì¹´ë“œ ì…ë ¥ (ë³´ì•ˆ ëª¨ë“œì—ì„œëŠ” ìˆ¨ê¹€)
  
ë‹¨ê³„4_ë°©ì†¡ì§„í–‰:
  - í”Œë ˆì´ì–´ ì•¡ì…˜ ì…ë ¥
  - ì»¤ë®¤ë‹ˆí‹° ì¹´ë“œ ì…ë ¥
  - ìë™ ê·¸ë˜í”½ ì—…ë°ì´íŠ¸ í™•ì¸
  - ìŠ¤íŠ¸ë¦¬ë° ì‹œì‘
```

---

## ğŸ”’ ë³´ì•ˆ ë° ë”œë ˆì´ ì‹œìŠ¤í…œ

### Secure Delay êµ¬í˜„

```javascript
class SecureDelaySystem {
  constructor(delayMinutes = 5) {
    this.delayTime = delayMinutes * 60 * 1000; // ë°€ë¦¬ì´ˆ
    this.liveBuffer = new CircularBuffer(1000);
    this.delayedOutput = new DelayedOutput(this.delayTime);
    this.isSecureMode = true;
  }
  
  // ì‹¤ì‹œê°„ ë°ì´í„° ì²˜ë¦¬
  processGameEvent(event) {
    // ë¼ì´ë¸Œ ë²„í¼ì— ì €ì¥ (ë”œëŸ¬/í”Œë ˆì´ì–´ìš©)
    this.liveBuffer.add({
      ...event,
      timestamp: Date.now()
    });
    
    // ì§€ì—°ëœ ì¶œë ¥ì— ì¶”ê°€ (ì‹œì²­ììš©)
    this.delayedOutput.schedule(event, this.delayTime);
    
    // ë³´ì•ˆ ëª¨ë“œì—ì„œëŠ” í™€ì¹´ë“œ ìˆ¨ê¹€
    if (this.isSecureMode && event.type === 'holecard_reveal') {
      event = this.censorHolecards(event);
    }
    
    return event;
  }
  
  // í•¸ë“œ ì¢…ë£Œ ì‹œ ì¦‰ì‹œ ê³µê°œ ì˜µì…˜
  onHandComplete(handData) {
    if (this.shouldRevealImmediately(handData)) {
      // ì§€ì—° ì—†ì´ ì¦‰ì‹œ ê³µê°œ
      this.delayedOutput.flushHand(handData.handId);
    }
  }
  
  shouldRevealImmediately(handData) {
    // ëª¨ë“  í”Œë ˆì´ì–´ê°€ í´ë“œí•œ ê²½ìš°
    if (handData.activePlayers <= 1) return true;
    
    // ì˜¬ì¸ ìƒí™©ì—ì„œ ì•¡ì…˜ì´ ëë‚œ ê²½ìš°
    if (handData.allInSituation && handData.bettingComplete) return true;
    
    return false;
  }
  
  censorHolecards(event) {
    return {
      ...event,
      cards: event.cards.map(card => ({ 
        rank: '?', 
        suit: '?', 
        hidden: true 
      }))
    };
  }
  
  // ê¸´ê¸‰ ìƒí™© ì‹œ ë¼ì´ë¸Œ ì „í™˜
  emergencyGoLive() {
    this.delayedOutput.flush();
    this.isSecureMode = false;
    console.log('Emergency: Switched to live mode');
  }
}

class DelayedOutput {
  constructor(delayTime) {
    this.delayTime = delayTime;
    this.eventQueue = [];
    this.outputTimer = setInterval(() => {
      this.processDelayedEvents();
    }, 1000);
  }
  
  schedule(event, delay) {
    const outputTime = Date.now() + delay;
    this.eventQueue.push({
      event: event,
      outputTime: outputTime
    });
  }
  
  processDelayedEvents() {
    const now = Date.now();
    const readyEvents = this.eventQueue.filter(item => item.outputTime <= now);
    
    readyEvents.forEach(item => {
      this.outputEvent(item.event);
    });
    
    // ì¶œë ¥ëœ ì´ë²¤íŠ¸ ì œê±°
    this.eventQueue = this.eventQueue.filter(item => item.outputTime > now);
  }
  
  outputEvent(event) {
    // ì§€ì—° ì¶œë ¥ (ì‹œì²­ììš© ìŠ¤íŠ¸ë¦¼ì— ì „ì†¡)
    this.broadcastToViewers(event);
  }
  
  flush() {
    // ëª¨ë“  ëŒ€ê¸° ì¤‘ì¸ ì´ë²¤íŠ¸ ì¦‰ì‹œ ì¶œë ¥
    this.eventQueue.forEach(item => {
      this.outputEvent(item.event);
    });
    this.eventQueue = [];
  }
}
```

---

## ğŸ“Š ë¶„ì„ ë° í†µê³„

### ê²Œì„ í†µê³„ ì‹œìŠ¤í…œ

```javascript
class PokerStatistics {
  constructor() {
    this.handHistory = [];
    this.playerStats = new Map();
    this.sessionStats = {
      handsPlayed: 0,
      totalPot: 0,
      avgPotSize: 0,
      sessionDuration: 0
    };
  }
  
  // í•¸ë“œ ì¢…ë£Œ ì‹œ í†µê³„ ì—…ë°ì´íŠ¸
  recordHand(handData) {
    this.handHistory.push(handData);
    this.updatePlayerStats(handData);
    this.updateSessionStats(handData);
  }
  
  updatePlayerStats(handData) {
    handData.players.forEach(player => {
      if (!this.playerStats.has(player.id)) {
        this.playerStats.set(player.id, {
          name: player.name,
          handsPlayed: 0,
          vpip: 0,
          pfr: 0,
          threeBet: 0,
          cbet: 0,
          totalWinnings: 0,
          bigBlindsPer100: 0,
          positions: {}
        });
      }
      
      const stats = this.playerStats.get(player.id);
      stats.handsPlayed++;
      
      // VPIP ê³„ì‚° (ìë°œì ìœ¼ë¡œ íŒŸì— ëˆì„ ë„£ì€ ë¹„ìœ¨)
      if (player.actions.some(action => 
        ['call', 'raise', 'bet'].includes(action.type) && 
        action.street === 'preflop'
      )) {
        stats.vpip = this.calculatePercentage(stats.vpipCount + 1, stats.handsPlayed);
      }
      
      // PFR ê³„ì‚° (í”„ë¦¬í”Œë ë ˆì´ì¦ˆ ë¹„ìœ¨)
      if (player.actions.some(action => 
        action.type === 'raise' && action.street === 'preflop'
      )) {
        stats.pfr = this.calculatePercentage(stats.pfrCount + 1, stats.handsPlayed);
      }
      
      // ìŠ¹ë¶€ ê²°ê³¼ ê¸°ë¡
      stats.totalWinnings += player.winnings || 0;
    });
  }
  
  calculatePercentage(count, total) {
    return total > 0 ? Math.round((count / total) * 100 * 10) / 10 : 0;
  }
  
  // ì‹¤ì‹œê°„ í†µê³„ í‘œì‹œìš© ë°ì´í„° ìƒì„±
  getDisplayStats() {
    const stats = [];
    
    for (const [playerId, playerStats] of this.playerStats) {
      stats.push({
        name: playerStats.name,
        hands: playerStats.handsPlayed,
        vpip: playerStats.vpip,
        pfr: playerStats.pfr,
        winnings: playerStats.totalWinnings,
        bb100: this.calculateBB100(playerStats)
      });
    }
    
    return stats.sort((a, b) => b.winnings - a.winnings);
  }
  
  calculateBB100(playerStats) {
    if (playerStats.handsPlayed < 10) return 0;
    
    const bigBlind = this.getCurrentBigBlind();
    const bb100 = (playerStats.totalWinnings / (playerStats.handsPlayed / 100)) / bigBlind;
    return Math.round(bb100 * 10) / 10;
  }
  
  // ì„¸ì…˜ ë¦¬í¬íŠ¸ ìƒì„±
  generateSessionReport() {
    return {
      summary: {
        handsPlayed: this.sessionStats.handsPlayed,
        duration: this.formatDuration(this.sessionStats.sessionDuration),
        totalAction: this.sessionStats.totalPot,
        avgPotSize: Math.round(this.sessionStats.avgPotSize)
      },
      playerStats: this.getDisplayStats(),
      biggestPots: this.getBiggestPots(5),
      mostActivePlayer: this.getMostActivePlayer(),
      sessionHighlights: this.generateHighlights()
    };
  }
  
  getBiggestPots(count) {
    return this.handHistory
      .sort((a, b) => b.totalPot - a.totalPot)
      .slice(0, count)
      .map(hand => ({
        handNumber: hand.handNumber,
        potSize: hand.totalPot,
        winner: hand.winner,
        showdown: hand.showdown
      }));
  }
  
  generateHighlights() {
    const highlights = [];
    
    // ê°€ì¥ í° íŒŸ
    const biggestPot = Math.max(...this.handHistory.map(h => h.totalPot));
    highlights.push(`Biggest pot: $${biggestPot}`);
    
    // ê°€ì¥ ë§ì´ ì´ê¸´ í”Œë ˆì´ì–´
    const biggestWinner = this.getDisplayStats()[0];
    if (biggestWinner) {
      highlights.push(`Biggest winner: ${biggestWinner.name} (+$${biggestWinner.winnings})`);
    }
    
    // ì˜¬ì¸ ìƒí™© íšŸìˆ˜
    const allInHands = this.handHistory.filter(h => h.hasAllIn).length;
    if (allInHands > 0) {
      highlights.push(`All-in situations: ${allInHands}`);
    }
    
    return highlights;
  }
}
```

---

## ğŸš€ ê²°ë¡ 

### ìš°ë¦¬ì˜ í˜ì‹ ì  ì ‘ê·¼ë²• ìš”ì•½

#### 1. ê¸°ì¡´ PokerGFXì˜ í•µì‹¬ ê¸°ëŠ¥ ë³´ì¡´
- âœ… ì‹¤ì‹œê°„ ì¹´ë“œ ì¶”ì  ë° í‘œì‹œ
- âœ… ì „ë¬¸ì ì¸ ê·¸ë˜í”½ ì˜¤ë²„ë ˆì´  
- âœ… ë‹¤ì¤‘ ë¹„ë””ì˜¤ ì†ŒìŠ¤ ì§€ì›
- âœ… ë³´ì•ˆ ë”œë ˆì´ ì‹œìŠ¤í…œ
- âœ… ìƒì„¸í•œ ê²Œì„ í†µê³„
- âœ… ìŠ¤íŠ¸ë¦¬ë° ë° ë…¹í™” ê¸°ëŠ¥

#### 2. í˜ì‹ ì  ê°œì„ ì‚¬í•­
- ğŸš€ **RFID ì˜ì¡´ì„± ì œê±°**: ì›¹ ê¸°ë°˜ ì¹´ë“œ ì…ë ¥ ì‹œìŠ¤í…œ
- ğŸš€ **ì ‘ê·¼ì„± í–¥ìƒ**: ë¸Œë¼ìš°ì €ì—ì„œ ë°”ë¡œ ì‹¤í–‰, ë³„ë„ ì„¤ì¹˜ ë¶ˆí•„ìš”
- ğŸš€ **ëª¨ë°”ì¼ ì§€ì›**: í„°ì¹˜ ì¹œí™”ì  Action Tracker
- ğŸš€ **í´ë¼ìš°ë“œ ì—°ë™**: ì‹¤ì‹œê°„ í˜‘ì—… ë° ë°±ì—…
- ğŸš€ **ë¹„ìš© íš¨ìœ¨ì„±**: ë¬´ë£Œ ì˜¤í”ˆì†ŒìŠ¤ ê¸°ë°˜, ì „ìš© í•˜ë“œì›¨ì–´ ë¶ˆí•„ìš”

#### 3. ì‹¤ìš©ì  êµ¬í˜„ ë°©ì•ˆ
- **ì›¹ ê¸°ìˆ  ìŠ¤íƒ**: Node.js + React + WebSocketìœ¼ë¡œ í¬ë¡œìŠ¤ í”Œë«í¼ ì§€ì›
- **OBS ì—°ë™**: WebSocket APIë¥¼ í†µí•œ ì™„ë²½í•œ ë°©ì†¡ ë„êµ¬ í†µí•©  
- **ë‹¨ê³„ë³„ ê°œë°œ**: í•µì‹¬ ê¸°ëŠ¥ë¶€í„° ê³ ê¸‰ ê¸°ëŠ¥ê¹Œì§€ ì ì§„ì  êµ¬í˜„
- **ì»¤ë®¤ë‹ˆí‹° ê¸°ë°˜**: ì˜¤í”ˆì†ŒìŠ¤ë¡œ ê°œë°œí•˜ì—¬ ì‚¬ìš©ì ê¸°ì—¬ í™œì„±í™”

### ê°œë°œ ìš°ì„ ìˆœìœ„

#### Phase 1: í•µì‹¬ ê¸°ëŠ¥ (3ê°œì›”)
1. ì›¹ ê¸°ë°˜ ê²Œì„ ìƒíƒœ ê´€ë¦¬ ì‹œìŠ¤í…œ
2. ì¹´ë“œ ì…ë ¥ ì¸í„°í˜ì´ìŠ¤ (ìˆ˜ë™)
3. Action Tracker (ëª¨ë°”ì¼ ì›¹)
4. ê¸°ë³¸ ê·¸ë˜í”½ ì˜¤ë²„ë ˆì´
5. OBS ì—°ë™

#### Phase 2: ê³ ê¸‰ ê¸°ëŠ¥ (3ê°œì›”)  
1. ë³´ì•ˆ ë”œë ˆì´ ì‹œìŠ¤í…œ
2. í†µê³„ ë° ë¶„ì„ ì‹œìŠ¤í…œ
3. ë‹¤ì¤‘ í…Œì´ë¸” ì§€ì›
4. ì»¤ìŠ¤í…€ í…Œë§ˆ ì‹œìŠ¤í…œ
5. í´ë¼ìš°ë“œ ê¸°ëŠ¥

#### Phase 3: í™•ì¥ ê¸°ëŠ¥ (3ê°œì›”)
1. ì»´í“¨í„° ë¹„ì „ ì¹´ë“œ ì¸ì‹ (ë³´ì¡°)
2. í† ë„ˆë¨¼íŠ¸ ëª¨ë“œ
3. í¬ìŠ¤íŠ¸ í”„ë¡œë•ì…˜ ë„êµ¬
4. API ë° í”ŒëŸ¬ê·¸ì¸ ì‹œìŠ¤í…œ
5. ëª¨ë°”ì¼ ì•±

ì´ ì„¤ê³„ ê¸°íšì„œë¥¼ ë°”íƒ•ìœ¼ë¡œ ê¸°ì¡´ PokerGFXì˜ ì¥ì ì€ ëª¨ë‘ ìœ ì§€í•˜ë©´ì„œ, ì ‘ê·¼ì„±ê³¼ ì‚¬ìš©ì„±ì„ ëŒ€í­ ê°œì„ í•œ í˜„ëŒ€ì ì¸ í¬ì»¤ ë°©ì†¡ ì†”ë£¨ì…˜ì„ ê°œë°œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

---

*ë³¸ ê¸°íšì„œëŠ” ì‹¤ì œ PokerGFX ë§¤ë‰´ì–¼ ë¶„ì„ì„ ë°”íƒ•ìœ¼ë¡œ ì‘ì„±ë˜ì—ˆìœ¼ë©°, ê¸°ì¡´ ì‚¬ìš©ìë“¤ì˜ ì›Œí¬í”Œë¡œìš°ë¥¼ ìµœëŒ€í•œ ë³´ì¡´í•˜ë©´ì„œë„ ë” ë‚˜ì€ ì‚¬ìš©ì ê²½í—˜ì„ ì œê³µí•˜ëŠ” ê²ƒì„ ëª©í‘œë¡œ í•©ë‹ˆë‹¤.*