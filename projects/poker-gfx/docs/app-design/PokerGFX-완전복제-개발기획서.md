# PokerGFX ì™„ì „ ë³µì œ ê°œë°œ ê¸°íšì„œ

## ğŸ“š ëª©ì°¨

1. [í”„ë¡œì íŠ¸ ê°œìš”](#1-í”„ë¡œì íŠ¸-ê°œìš”)
2. [ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜](#2-ì‹œìŠ¤í…œ-ì•„í‚¤í…ì²˜)
3. [í•µì‹¬ ì»´í¬ë„ŒíŠ¸ ìƒì„¸ ì„¤ê³„](#3-í•µì‹¬-ì»´í¬ë„ŒíŠ¸-ìƒì„¸-ì„¤ê³„)
4. [ë°ì´í„° í”Œë¡œìš° ë° ë…¼ë¦¬ êµ¬ì¡°](#4-ë°ì´í„°-í”Œë¡œìš°-ë°-ë…¼ë¦¬-êµ¬ì¡°)
5. [ì‚¬ìš©ì ì›Œí¬í”Œë¡œìš°](#5-ì‚¬ìš©ì-ì›Œí¬í”Œë¡œìš°)
6. [ê¸°ìˆ  êµ¬í˜„ ëª…ì„¸](#6-ê¸°ìˆ -êµ¬í˜„-ëª…ì„¸)
7. [ê°œë°œ ë¡œë“œë§µ](#7-ê°œë°œ-ë¡œë“œë§µ)

---

## 1. í”„ë¡œì íŠ¸ ê°œìš”

### ğŸ¯ í”„ë¡œì íŠ¸ ëª©í‘œ

**ê¸°ì¡´ PokerGFXì˜ ëª¨ë“  ê¸°ëŠ¥ì„ ì™„ì „íˆ ë³µì œ**í•˜ì—¬ ë™ì¼í•œ ìˆ˜ì¤€ì˜ ì „ë¬¸ì ì¸ í¬ì»¤ ë°©ì†¡ ì†”ë£¨ì…˜ì„ ê°œë°œí•©ë‹ˆë‹¤. ì´ëŠ” í˜ì‹ ì´ë‚˜ ê°œì„ ì´ ì•„ë‹Œ, ê²€ì¦ëœ ì‹œìŠ¤í…œì˜ **ì •í™•í•œ ë³µì œ**ë¥¼ ëª©í‘œë¡œ í•©ë‹ˆë‹¤.

### ğŸ“‹ PokerGFXë€ ë¬´ì—‡ì¸ê°€?

PokerGFXëŠ” ì „ë¬¸ì ì¸ í¬ì»¤ ë°©ì†¡ì„ ìœ„í•œ ì™„ì „ í†µí•© ì†”ë£¨ì…˜ì…ë‹ˆë‹¤:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  PokerGFX ì‹œìŠ¤í…œ                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  RFID Reader â†’ Cards Detection â†’ Graphics Engine        â”‚
â”‚       â†“              â†“               â†“                  â”‚
â”‚  USB 3.0      Real-time Data    Video Overlay           â”‚
â”‚                      â†“               â†“                  â”‚
â”‚              Action Tracker    Streaming Output         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ğŸ—ï¸ ì‹œìŠ¤í…œ êµ¬ì„± ìš”ì†Œ

#### 1. í•˜ë“œì›¨ì–´ ì»´í¬ë„ŒíŠ¸
- **RFID Reader**: USB 3.0 ì—°ê²°, ì „ìš© ì „ì›, WiFi ì˜µì…˜
- **RFID ì¹´ë“œ**: 52ì¥ ì „ìš© ë±, ê°œë³„ ë“±ë¡ í•„ìš”
- **ë¹„ë””ì˜¤ ìº¡ì²˜**: ìµœëŒ€ 16ê°œ ì†ŒìŠ¤ (ë¼ì´ì„ ìŠ¤ë³„ ì°¨ì´)
- **ê³ ì„±ëŠ¥ PC**: Windows ì „ìš©, GPU ê°€ì† í•„ìˆ˜

#### 2. ì†Œí”„íŠ¸ì›¨ì–´ ì»´í¬ë„ŒíŠ¸
- **PokerGFX Server**: ë©”ì¸ ì• í”Œë¦¬ì¼€ì´ì…˜ (C++/C#)
- **Action Tracker**: ë³„ë„ Windows ì•±
- **Studio**: í¬ìŠ¤íŠ¸ í”„ë¡œë•ì…˜ (Pro ì´ìƒ)
- **MultiGFX**: ë‹¤ì¤‘ ì¶œë ¥ ë™ê¸°í™”

### ğŸ“Š ë¼ì´ì„ ìŠ¤ë³„ ê¸°ëŠ¥ êµ¬ë¶„

| ê¸°ëŠ¥ | Basic | Pro | Enterprise |
|------|-------|-----|------------|
| ë¹„ë””ì˜¤ ì†ŒìŠ¤ | 4ê°œ | 8ê°œ | 16ê°œ |
| RFID ì§€ì› | âœ“ | âœ“ | âœ“ |
| Action Tracker | âœ“ | âœ“ | âœ“ |
| Studio | âœ— | âœ“ | âœ“ |
| í”Œë ˆì´ì–´ ì‚¬ì§„ | âœ— | âœ“ | âœ“ |
| ì§€ì—°ì‹œê°„ | 30ë¶„ | 60ë¶„ | 60ë¶„ |
| API ì ‘ê·¼ | âœ— | âœ— | âœ“ |
| NDI ì¶œë ¥ | âœ— | âœ— | âœ“ |

---

## 2. ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜

### ğŸ›ï¸ ì „ì²´ ì‹œìŠ¤í…œ êµ¬ì¡°

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     ë¬¼ë¦¬ì  í•˜ë“œì›¨ì–´ ê³„ì¸µ                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  RFID Reader  â”‚  Video Capture  â”‚  Audio Input  â”‚  Network   â”‚
â”‚   (USB 3.0)   â”‚   (HDMI/SDI)    â”‚   (Line/Mic)  â”‚  (Gigabit) â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     ìš´ì˜ì²´ì œ ê³„ì¸µ                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚           Windows 10/11 (64-bit)                           â”‚
â”‚       DirectShow â€¢ DirectX â€¢ WinAPI                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   PokerGFX Server                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  RFID Manager  â”‚  Video Engine  â”‚  Graphics Engine          â”‚
â”‚  Game Logic    â”‚  Stream Output â”‚  Network Server           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      ì™¸ë¶€ ì—°ê²°                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Action Tracker â”‚  OBS Studio   â”‚  Streaming Platforms      â”‚
â”‚  (ë„¤íŠ¸ì›Œí¬)      â”‚  (WebSocket)   â”‚  (RTMP/WebRTC)           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ğŸ”§ í•µì‹¬ ì•„í‚¤í…ì²˜ ì›ì¹™

#### 1. **Windows ë„¤ì´í‹°ë¸Œ ì•„í‚¤í…ì²˜**
- C++/C# í˜¼í•© ê°œë°œ
- DirectX 11/12 GPU ê°€ì†
- WinAPI ì‹œìŠ¤í…œ í†µí•©
- .NET Framework 4.8+

#### 2. **ì‹¤ì‹œê°„ ì²˜ë¦¬ íŒŒì´í”„ë¼ì¸**
```
RFID Data â†’ Game State â†’ Graphics Render â†’ Video Composite â†’ Stream Output
    â†“           â†“             â†“              â†“              â†“
  100ms      16ms         16ms          16ms          33ms
```

#### 3. **ëª¨ë“ˆí˜• ì„¤ê³„**
- ê° ê¸°ëŠ¥ì„ ë…ë¦½ì  DLLë¡œ ë¶„ë¦¬
- í”ŒëŸ¬ê·¸ì¸ ì•„í‚¤í…ì²˜ ì§€ì›
- ë¼ì´ì„ ìŠ¤ë³„ ëª¨ë“ˆ í™œì„±í™”
- ëŸ°íƒ€ì„ ê¸°ëŠ¥ í™•ì¥

### ğŸ—ƒï¸ ë°ì´í„°ë² ì´ìŠ¤ êµ¬ì¡°

```sql
-- ê²Œì„ ìƒíƒœ í…Œì´ë¸”
CREATE TABLE GameState (
    id INTEGER PRIMARY KEY,
    table_name VARCHAR(100),
    game_type VARCHAR(50),
    small_blind DECIMAL(10,2),
    big_blind DECIMAL(10,2),
    created_at TIMESTAMP
);

-- í”Œë ˆì´ì–´ ì •ë³´
CREATE TABLE Players (
    id INTEGER PRIMARY KEY,
    game_id INTEGER,
    seat_number INTEGER,
    player_name VARCHAR(100),
    chip_count DECIMAL(12,2),
    is_active BOOLEAN,
    photo_path VARCHAR(255),
    country_code VARCHAR(3)
);

-- ì¹´ë“œ ë°ì´í„°
CREATE TABLE Cards (
    id INTEGER PRIMARY KEY,
    rfid_tag VARCHAR(50) UNIQUE,
    rank VARCHAR(2),
    suit VARCHAR(10),
    deck_id INTEGER,
    registered_at TIMESTAMP
);

-- í•¸ë“œ íˆìŠ¤í† ë¦¬
CREATE TABLE Hands (
    id INTEGER PRIMARY KEY,
    game_id INTEGER,
    hand_number INTEGER,
    dealer_position INTEGER,
    pot_size DECIMAL(12,2),
    board_cards VARCHAR(50),
    started_at TIMESTAMP,
    ended_at TIMESTAMP
);
```

---

## 3. í•µì‹¬ ì»´í¬ë„ŒíŠ¸ ìƒì„¸ ì„¤ê³„

### ğŸ¯ ì»´í¬ë„ŒíŠ¸ 1: RFID ê´€ë¦¬ì

#### ğŸ“ ì—­í• ê³¼ ì±…ì„
RFID Readerì™€ì˜ í†µì‹ ì„ ê´€ë¦¬í•˜ê³  ì¹´ë“œ ë°ì´í„°ë¥¼ ì‹¤ì‹œê°„ìœ¼ë¡œ ì²˜ë¦¬í•©ë‹ˆë‹¤.

#### ğŸ”§ ê¸°ìˆ  êµ¬í˜„

```cpp
// RFIDManager.h
class RFIDManager {
public:
    struct CardData {
        std::string rfidTag;
        std::string rank;
        std::string suit;
        int position;
        double timestamp;
        double signalStrength;
    };

    enum ConnectionStatus {
        DISCONNECTED,
        CONNECTING,
        CONNECTED,
        ERROR
    };

private:
    // USB ì—°ê²° ê´€ë¦¬
    HANDLE m_deviceHandle;
    std::thread m_readerThread;
    std::queue<CardData> m_cardQueue;
    std::mutex m_queueMutex;
    
    // ìº˜ë¦¬ë¸Œë ˆì´ì…˜ ë°ì´í„°
    std::vector<CalibrationPoint> m_playerPositions;
    std::vector<CalibrationPoint> m_boardPositions;
    
    // ì¹´ë“œ ë“±ë¡ ë°ì´í„°ë² ì´ìŠ¤
    std::unordered_map<std::string, CardInfo> m_registeredCards;

public:
    // ì—°ê²° ê´€ë¦¬
    bool Connect();
    void Disconnect();
    ConnectionStatus GetStatus();
    
    // ìº˜ë¦¬ë¸Œë ˆì´ì…˜
    bool StartCalibration();
    void AddCalibrationPoint(int seatNumber, double x, double y);
    bool SaveCalibration();
    bool LoadCalibration();
    
    // ì¹´ë“œ ë“±ë¡
    bool RegisterDeck(const std::vector<CardInfo>& cards);
    bool CheckDeck();
    
    // ì‹¤ì‹œê°„ ê°ì§€
    void StartReading();
    void StopReading();
    std::vector<CardData> GetDetectedCards();
    
    // ì´ë²¤íŠ¸ ì½œë°±
    void SetCardDetectedCallback(std::function<void(CardData)> callback);
    void SetConnectionStatusCallback(std::function<void(ConnectionStatus)> callback);

private:
    void ReaderThreadFunction();
    bool ProcessRFIDData(const uint8_t* data, size_t length);
    CardData ParseCardData(const uint8_t* data);
    bool ValidateCardData(const CardData& card);
};
```

#### ğŸ“Š ìƒíƒœ ê´€ë¦¬ ë‹¤ì´ì–´ê·¸ë¨

```
ì´ˆê¸°í™” â†’ USB ì—°ê²° â†’ íŒì›¨ì–´ í™•ì¸ â†’ ìº˜ë¦¬ë¸Œë ˆì´ì…˜ ë¡œë“œ â†’ ì¹´ë“œ DB ë¡œë“œ â†’ ëŒ€ê¸°
   â†“         â†“          â†“             â†“              â†“           â†“
ì˜¤ë¥˜ì‹œ    ì‹œê°„ì´ˆê³¼     ë²„ì „ë¶ˆì¼ì¹˜      ì‹¤íŒ¨ì‹œ          ì‹¤íŒ¨ì‹œ       ê°ì§€ì‹œì‘
ì¬ì‹œë„    ì¬ì—°ê²°      ì—…ë°ì´íŠ¸ìš”ì²­    ìº˜ë¦¬ë¸Œë ˆì´ì…˜     ë±ë“±ë¡      ì¹´ë“œì´ë²¤íŠ¸
```

### ğŸ¯ ì»´í¬ë„ŒíŠ¸ 2: ê²Œì„ ë¡œì§ ì—”ì§„

#### ğŸ“ ì—­í• ê³¼ ì±…ì„
í¬ì»¤ ê²Œì„ì˜ ëª¨ë“  ë£°ê³¼ ìƒíƒœë¥¼ ê´€ë¦¬í•˜ê³ , ì•¡ì…˜ ì²˜ë¦¬ ë° ê²°ê³¼ ê³„ì‚°ì„ ë‹´ë‹¹í•©ë‹ˆë‹¤.

#### ğŸ”§ ê¸°ìˆ  êµ¬í˜„

```cpp
// GameEngine.h
class GameEngine {
public:
    enum GameType {
        HOLDEM_NO_LIMIT,
        HOLDEM_LIMIT,
        HOLDEM_POT_LIMIT,
        OMAHA_POT_LIMIT,
        OMAHA_HI_LO,
        STUD_7_CARD,
        RAZZ,
        MIXED_GAMES
    };

    enum BettingRound {
        PREFLOP,
        FLOP,
        TURN,
        RIVER,
        SHOWDOWN
    };

    enum PlayerAction {
        FOLD,
        CHECK,
        CALL,
        RAISE,
        ALL_IN,
        SIT_OUT
    };

    struct Player {
        int seatNumber;
        std::string name;
        double chipStack;
        std::vector<Card> holeCards;
        PlayerAction lastAction;
        double currentBet;
        bool isActive;
        bool hasActed;
        std::string photoPath;
        std::string countryCode;
    };

    struct HandData {
        int handNumber;
        int dealerPosition;
        std::vector<Player> players;
        std::vector<Card> boardCards;
        std::vector<Pot> pots;
        BettingRound currentRound;
        double totalPot;
        Player* activePlayer;
        std::vector<ActionHistory> actions;
    };

private:
    GameType m_gameType;
    HandData m_currentHand;
    std::vector<Player> m_players;
    std::mt19937 m_randomEngine;
    
    // ë² íŒ… êµ¬ì¡°
    double m_smallBlind;
    double m_bigBlind;
    double m_ante;
    
    // ê²Œì„ ì„¤ì •
    bool m_runItTwice;
    bool m_allowStraddle;
    int m_maxPlayers;

public:
    // ê²Œì„ ì„¤ì •
    void SetGameType(GameType type);
    void SetBlinds(double small, double big, double ante = 0);
    void AddPlayer(const Player& player);
    void RemovePlayer(int seatNumber);
    
    // í•¸ë“œ ê´€ë¦¬
    bool StartNewHand();
    void DealCards();
    void SetPlayerCards(int seatNumber, const std::vector<Card>& cards);
    void SetBoardCards(const std::vector<Card>& cards);
    
    // ì•¡ì…˜ ì²˜ë¦¬
    bool ProcessAction(int seatNumber, PlayerAction action, double amount = 0);
    bool CanPerformAction(int seatNumber, PlayerAction action);
    double GetMinRaise();
    double GetCallAmount(int seatNumber);
    
    // ê²Œì„ ìƒíƒœ
    BettingRound GetCurrentRound();
    Player* GetActivePlayer();
    std::vector<Pot> CalculatePots();
    bool IsHandComplete();
    
    // íŠ¹ìˆ˜ ìƒí™©
    void HandleAllIn(int seatNumber);
    void CreateSidePot();
    void HandleRunItTwice();
    void ShowCards(int seatNumber);
    
    // ì´ë²¤íŠ¸
    void SetActionCallback(std::function<void(ActionEvent)> callback);
    void SetHandCompleteCallback(std::function<void(HandResult)> callback);

private:
    void AdvanceBettingRound();
    void DetermineWinners();
    void AwardPots();
    bool IsBettingRoundComplete();
    void MoveToNextPlayer();
    void ValidateGameState();
};
```

### ğŸ¯ ì»´í¬ë„ŒíŠ¸ 3: ê·¸ë˜í”½ ë Œë”ë§ ì—”ì§„

#### ğŸ“ ì—­í• ê³¼ ì±…ì„
ì‹¤ì‹œê°„ìœ¼ë¡œ ê²Œì„ ì •ë³´ë¥¼ ì‹œê°í™”í•˜ê³  ë°©ì†¡ìš© ì˜¤ë²„ë ˆì´ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.

#### ğŸ”§ ê¸°ìˆ  êµ¬í˜„

```cpp
// GraphicsEngine.h
class GraphicsEngine {
public:
    struct RenderSettings {
        int outputWidth;
        int outputHeight;
        int framerate;
        bool enableAlpha;
        bool enable4K;
        std::string skinName;
    };

    struct PlayerGraphics {
        Vector2 position;
        Vector2 size;
        std::string name;
        double chipCount;
        std::vector<Card> cards;
        PlayerAction lastAction;
        double actionAmount;
        bool isActive;
    };

    struct GraphicsContext {
        ID3D11Device* device;
        ID3D11DeviceContext* context;
        IDXGISwapChain* swapChain;
        ID3D11RenderTargetView* renderTarget;
        ID3D11Texture2D* alphaTexture;
    };

private:
    GraphicsContext m_d3dContext;
    RenderSettings m_settings;
    
    // ë Œë”ë§ ë¦¬ì†ŒìŠ¤
    std::unordered_map<std::string, ID3D11Texture2D*> m_textures;
    std::unordered_map<std::string, ID3D11ShaderResourceView*> m_shaderViews;
    std::vector<std::unique_ptr<Sprite>> m_sprites;
    
    // ì• ë‹ˆë©”ì´ì…˜ ì‹œìŠ¤í…œ
    AnimationManager m_animationManager;
    ParticleSystem m_particles;
    
    // í°íŠ¸ ë° í…ìŠ¤íŠ¸
    std::unique_ptr<DirectWrite> m_textRenderer;
    std::unordered_map<std::string, FontData> m_fonts;

public:
    // ì´ˆê¸°í™”
    bool Initialize(HWND hwnd, const RenderSettings& settings);
    void Shutdown();
    
    // ë Œë”ë§ ì œì–´
    void BeginFrame();
    void EndFrame();
    void Present();
    void Clear(const Color& color);
    
    // ê·¸ë˜í”½ ìš”ì†Œ ë Œë”ë§
    void RenderPlayers(const std::vector<PlayerGraphics>& players);
    void RenderBoard(const std::vector<Card>& cards, BettingRound round);
    void RenderPot(double amount, const std::vector<double>& sidePots);
    void RenderActions(const std::vector<ActionIndicator>& actions);
    void RenderStatistics(const PlayerStats& stats);
    
    // ìŠ¤í‚¨ ì‹œìŠ¤í…œ
    bool LoadSkin(const std::string& skinName);
    void SetSkinParameter(const std::string& key, const Variant& value);
    
    // ì• ë‹ˆë©”ì´ì…˜
    void StartCardAnimation(const Card& card, AnimationType type);
    void StartPotAnimation(double fromAmount, double toAmount);
    void StartPlayerElimination(int seatNumber);
    
    // ì¶œë ¥ ì œì–´
    void SetOutputFormat(OutputFormat format);
    void EnableAlphaChannel(bool enable);
    ID3D11Texture2D* GetOutputTexture();

private:
    void CreateDeviceResources();
    void CreateRenderTarget();
    void LoadShaders();
    void LoadTextures();
    void SetupBlendStates();
};
```

### ğŸ¯ ì»´í¬ë„ŒíŠ¸ 4: Action Tracker í´ë¼ì´ì–¸íŠ¸

#### ğŸ“ ì—­í• ê³¼ ì±…ì„
ë³„ë„ Windows ì• í”Œë¦¬ì¼€ì´ì…˜ìœ¼ë¡œ ë² íŒ… ì•¡ì…˜ì„ ì…ë ¥í•˜ê³  ë©”ì¸ ì„œë²„ì™€ í†µì‹ í•©ë‹ˆë‹¤.

#### ğŸ”§ ê¸°ìˆ  êµ¬í˜„

```cpp
// ActionTracker.h (Windows Forms ì• í”Œë¦¬ì¼€ì´ì…˜)
public ref class ActionTrackerForm : public System::Windows::Forms::Form {
private:
    // ë„¤íŠ¸ì›Œí¬ í†µì‹ 
    System::Net::Sockets::TcpClient^ tcpClient;
    System::IO::NetworkStream^ networkStream;
    System::Threading::Thread^ messageListener;
    
    // UI ì»¨íŠ¸ë¡¤
    array<System::Windows::Forms::Button^>^ seatButtons;
    System::Windows::Forms::Panel^ actionPanel;
    System::Windows::Forms::Label^ potLabel;
    System::Windows::Forms::Label^ boardLabel;
    System::Windows::Forms::NumericUpDown^ betAmount;
    
    // ê²Œì„ ìƒíƒœ
    GameState currentGameState;
    int activeSeat;
    bool isConnected;

public:
    ActionTrackerForm() {
        InitializeComponent();
        SetupNetworking();
        SetupEventHandlers();
    }

    // ì—°ê²° ê´€ë¦¬
    void ConnectToServer(String^ ipAddress, int port);
    void Disconnect();
    void OnConnectionLost();
    
    // ê²Œì„ ìƒíƒœ ì—…ë°ì´íŠ¸
    void UpdateGameState(GameState^ state);
    void UpdatePlayerInfo(int seat, PlayerInfo^ info);
    void UpdateBoard(array<Card^>^ cards);
    void UpdatePot(double amount);
    
    // ì•¡ì…˜ ì²˜ë¦¬
    void ProcessPlayerAction(int seat, PlayerAction action, double amount);
    void SendActionToServer(ActionData^ action);
    void ValidateAction(PlayerAction action, double amount);
    
    // UI ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬
    void OnSeatButton_Click(Object^ sender, EventArgs^ e);
    void OnActionButton_Click(Object^ sender, EventArgs^ e);
    void OnBetAmount_ValueChanged(Object^ sender, EventArgs^ e);

private:
    void InitializeComponent();
    void SetupSeatLayout();
    void SetupActionButtons();
    void UpdateSeatDisplay(int seat);
    void ShowActionButtons(int seat);
    void HideActionButtons();
    
    // ë„¤íŠ¸ì›Œí¬ ë©”ì‹œì§€ ì²˜ë¦¬
    void MessageListenerThread();
    void ProcessIncomingMessage(String^ message);
    void SendMessage(String^ message);
    
    // ìœ íš¨ì„± ê²€ì‚¬
    bool CanPlayerAct(int seat);
    bool IsValidRaise(double amount);
    double GetMinRaise();
    double GetMaxRaise(int seat);
};
```

---

## 4. ë°ì´í„° í”Œë¡œìš° ë° ë…¼ë¦¬ êµ¬ì¡°

### ğŸ”„ ì „ì²´ ë°ì´í„° í”Œë¡œìš°

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ RFID Reader â”‚â”€â”€â”€â–¶â”‚ Card Parser â”‚â”€â”€â”€â–¶â”‚ Game Engine â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                              â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚Action Trackerâ”‚â—€â”€â”€â”‚Network Layerâ”‚â—€â”€â”€â”€â”‚Game State   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚Manager      â”‚
                                      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                              â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚Stream Outputâ”‚â—€â”€â”€â”€â”‚Graphics     â”‚â—€â”€â”€â”€â”‚Render       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚Engine       â”‚    â”‚Queue        â”‚
                   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ğŸ“Š ìƒì„¸ í”„ë¡œì„¸ìŠ¤ íë¦„

#### 1. **ì¹´ë“œ ê°ì§€ í”„ë¡œì„¸ìŠ¤**

```
RFID ì‹ í˜¸ ìˆ˜ì‹ 
     â†“
ì‹ í˜¸ ê°•ë„ í™•ì¸ (>-60dBm)
     â†“
RFID íƒœê·¸ íŒŒì‹±
     â†“
ë“±ë¡ëœ ì¹´ë“œ DB ì¡°íšŒ
     â†“
ìœ„ì¹˜ ì •ë³´ ë§¤í•‘ (ìº˜ë¦¬ë¸Œë ˆì´ì…˜ ë°ì´í„°)
     â†“
ì¤‘ë³µ ê°ì§€ í•„í„°ë§ (200ms ìœˆë„ìš°)
     â†“
ê²Œì„ ì—”ì§„ìœ¼ë¡œ ì „ì†¡
```

#### 2. **ê²Œì„ ìƒíƒœ ì—…ë°ì´íŠ¸ í”„ë¡œì„¸ìŠ¤**

```cpp
// ê²Œì„ ìƒíƒœ ì—…ë°ì´íŠ¸ ë¡œì§
void GameEngine::ProcessCardDetection(const CardData& cardData) {
    // 1. ì¹´ë“œ ìœ íš¨ì„± ê²€ì¦
    if (!ValidateCard(cardData)) {
        LogError("Invalid card detected: " + cardData.rfidTag);
        return;
    }
    
    // 2. ê²Œì„ ë‹¨ê³„ë³„ ì²˜ë¦¬
    switch (m_currentHand.currentRound) {
        case BettingRound::PREFLOP:
            ProcessHoleCard(cardData);
            break;
        case BettingRound::FLOP:
        case BettingRound::TURN:
        case BettingRound::RIVER:
            ProcessBoardCard(cardData);
            break;
        default:
            // í•¸ë“œ ì™„ë£Œ í›„ ê°ì§€ëœ ì¹´ë“œëŠ” ë¬´ì‹œ
            break;
    }
    
    // 3. UI ì—…ë°ì´íŠ¸ ì´ë²¤íŠ¸ ë°œìƒ
    NotifyCardUpdate(cardData);
    
    // 4. ê·¸ë˜í”½ ë Œë”ë§ íì— ì¶”ê°€
    m_renderQueue.push(CreateCardRenderEvent(cardData));
}
```

#### 3. **ì•¡ì…˜ ì²˜ë¦¬ í”„ë¡œì„¸ìŠ¤**

```cpp
// Action Trackerì—ì„œ ì„œë²„ë¡œ ì•¡ì…˜ ì „ì†¡
void ActionTrackerForm::ProcessPlayerAction(int seatNumber, PlayerAction action, double amount) {
    // 1. í´ë¼ì´ì–¸íŠ¸ ì‚¬ì´ë“œ ìœ íš¨ì„± ê²€ì‚¬
    if (!ValidateAction(seatNumber, action, amount)) {
        ShowError("Invalid action");
        return;
    }
    
    // 2. ì•¡ì…˜ ë°ì´í„° êµ¬ì„±
    ActionMessage message;
    message.playerId = seatNumber;
    message.action = action;
    message.amount = amount;
    message.timestamp = GetCurrentTimestamp();
    message.handNumber = currentGameState.handNumber;
    
    // 3. ì„œë²„ë¡œ ì „ì†¡
    SendActionToServer(message);
    
    // 4. UI ì„ì‹œ ì—…ë°ì´íŠ¸ (ì„œë²„ ì‘ë‹µ ëŒ€ê¸°)
    UpdatePlayerDisplay(seatNumber, action, amount);
}

// ì„œë²„ì—ì„œ ì•¡ì…˜ ì²˜ë¦¬
bool GameEngine::ProcessAction(int seatNumber, PlayerAction action, double amount) {
    // 1. ì„œë²„ ì‚¬ì´ë“œ ê²€ì¦
    Player* player = GetPlayer(seatNumber);
    if (!player || !CanPlayerAct(player)) {
        return false;
    }
    
    // 2. ì•¡ì…˜ë³„ ì²˜ë¦¬
    switch (action) {
        case PlayerAction::FOLD:
            player->isActive = false;
            player->holeCards.clear(); // ë³´ì•ˆìƒ ì¹´ë“œ ìˆ¨ê¹€
            break;
            
        case PlayerAction::CALL:
            amount = GetCallAmount(seatNumber);
            player->chipStack -= amount;
            player->currentBet += amount;
            m_currentHand.totalPot += amount;
            break;
            
        case PlayerAction::RAISE:
            if (amount < GetMinRaise()) return false;
            player->chipStack -= amount;
            player->currentBet = amount;
            m_currentHand.totalPot += amount;
            m_currentBet = amount;
            break;
            
        case PlayerAction::ALL_IN:
            amount = player->chipStack;
            player->chipStack = 0;
            player->currentBet += amount;
            m_currentHand.totalPot += amount;
            HandleAllIn(seatNumber);
            break;
    }
    
    // 3. ê²Œì„ ìƒíƒœ ì—…ë°ì´íŠ¸
    player->lastAction = action;
    player->hasActed = true;
    
    // 4. ë‹¤ìŒ í”Œë ˆì´ì–´ë¡œ ì•¡ì…˜ ì´ë™
    AdvanceAction();
    
    // 5. ë² íŒ… ë¼ìš´ë“œ ì™„ë£Œ ì²´í¬
    if (IsBettingRoundComplete()) {
        AdvanceBettingRound();
    }
    
    // 6. ëª¨ë“  í´ë¼ì´ì–¸íŠ¸ì— ì—…ë°ì´íŠ¸ ë¸Œë¡œë“œìºìŠ¤íŠ¸
    BroadcastGameState();
    
    return true;
}
```

### ğŸ¨ ê·¸ë˜í”½ ë Œë”ë§ íŒŒì´í”„ë¼ì¸

```
ê²Œì„ ìƒíƒœ ë³€ê²½
     â†“
ë Œë” ì´ë²¤íŠ¸ ìƒì„±
     â†“
ë Œë” íì— ì¶”ê°€
     â†“
í”„ë ˆì„ ì‹œì‘ (60 FPS)
     â†“
ì´ë²¤íŠ¸ ì²˜ë¦¬ (ë°°ì¹˜)
     â†“
DirectX ë Œë”ë§
     â†“
í¬ìŠ¤íŠ¸ í”„ë¡œì„¸ì‹±
     â†“
ì¶œë ¥ ë²„í¼ë¡œ ë³µì‚¬
     â†“
ìŠ¤íŠ¸ë¦¼/ë…¹í™” ì¶œë ¥
```

---

## 5. ì‚¬ìš©ì ì›Œí¬í”Œë¡œìš°

### ğŸ‘¤ ì‚¬ìš©ìë³„ ì›Œí¬í”Œë¡œìš° ìƒì„¸ ê°€ì´ë“œ

#### ğŸ”§ ê´€ë¦¬ì (ë°©ì†¡ ìš´ì˜ì) ì›Œí¬í”Œë¡œìš°

**1ë‹¨ê³„: ì‹œìŠ¤í…œ ì´ˆê¸° ì„¤ì •**
```
ì‹œì‘ â†’ PokerGFX Server ì‹¤í–‰ â†’ ë¼ì´ì„ ìŠ¤ í™•ì¸ â†’ RFID Reader ì—°ê²° í™•ì¸
  â†“
USB ì—°ê²° ìƒíƒœ ì²´í¬ â†’ ì „ì› ê³µê¸‰ í™•ì¸ â†’ ë“œë¼ì´ë²„ ì„¤ì¹˜ ìƒíƒœ ì ê²€
  â†“
ì—°ê²° ì„±ê³µ ì‹œ: ë…¹ìƒ‰ í‘œì‹œë“± â†’ ì‹¤íŒ¨ ì‹œ: ë¹¨ê°„ìƒ‰ + ì˜¤ë¥˜ ë©”ì‹œì§€
```

**2ë‹¨ê³„: í…Œì´ë¸” ìº˜ë¦¬ë¸Œë ˆì´ì…˜**
```
Settings â†’ RFID â†’ Calibrate Table
  â†“
ìº˜ë¦¬ë¸Œë ˆì´ì…˜ ë§ˆë²•ì‚¬ ì‹œì‘
  â†“
ê° ì¢Œì„ë³„ ì¹´ë“œ ë°°ì¹˜ (1ë²ˆ ì¢Œì„ë¶€í„° ì‹œê³„ë°©í–¥)
  â†“
"Detect" ë²„íŠ¼ í´ë¦­ â†’ RFID ì‹ í˜¸ ê°•ë„ í™•ì¸ â†’ ìœ„ì¹˜ ì €ì¥
  â†“
ë³´ë“œ ìœ„ì¹˜ ì„¤ì • (Flop, Turn, River ê°ê°)
  â†“
ìº˜ë¦¬ë¸Œë ˆì´ì…˜ ì™„ë£Œ â†’ ë°ì´í„° ìë™ ì €ì¥
```

**3ë‹¨ê³„: ì¹´ë“œ ë± ë“±ë¡**
```
ìƒˆ ë± ì¤€ë¹„ (52ì¥, ì¡°ì»¤ ì œê±°)
  â†“
Settings â†’ RFID â†’ Register Deck
  â†“
ë± ì´ë¦„ ì…ë ¥ (ì˜ˆ: "Red Deck #1")
  â†“
ì¹´ë“œ í•˜ë‚˜ì”© RFID Readerì— ì˜¬ë¦¬ê¸°
  â†“
ì‹œìŠ¤í…œì´ ìë™ìœ¼ë¡œ Rank + Suit ì¸ì‹
  â†“
ì§„í–‰ ìƒí™© í‘œì‹œ (1/52, 2/52, ...)
  â†“
52ì¥ ì™„ë£Œ â†’ ì¤‘ë³µ/ëˆ„ë½ ì¹´ë“œ ì²´í¬ â†’ ì €ì¥
```

**4ë‹¨ê³„: ë¹„ë””ì˜¤ ì†ŒìŠ¤ ì„¤ì •**
```
Sources íƒ­ í´ë¦­
  â†“
Add Source â†’ USB Camera/Capture Card/NDI ì„ íƒ
  â†“
ê° ì†ŒìŠ¤ë³„ ì„¤ì •:
- Resolution: 1920x1080 or 3840x2160
- Frame Rate: 30fps or 60fps
- Audio: Enable/Disable
  â†“
í”„ë¦¬ë·° í™•ì¸ â†’ ëª¨ë“  ì¹´ë©”ë¼ í…ŒìŠ¤íŠ¸
```

**5ë‹¨ê³„: ìŠ¤íŠ¸ë¦¬ë° ì„¤ì •**
```
Outputs íƒ­ í´ë¦­
  â†“
Streaming â†’ Platform ì„ íƒ (Twitch/YouTube/Custom)
  â†“
Stream Key ì…ë ¥
  â†“
ë¹„íŠ¸ë ˆì´íŠ¸ ì„¤ì • (6000 kbps ê¶Œì¥)
  â†“
Test Connection â†’ ì—°ê²° ì„±ê³µ í™•ì¸
```

#### ğŸ® ë”œëŸ¬ ì›Œí¬í”Œë¡œìš°

**ê²Œì„ ì‹œì‘ ì „ ì¤€ë¹„**
```
ë± ì…”í”Œ â†’ Action Tracker "CHECK" ë²„íŠ¼ â†’ 52ì¥ ì „ì²´ í™•ì¸
  â†“
ëˆ„ë½/ì¤‘ë³µ ì¹´ë“œ ìˆìœ¼ë©´: ì¹´ë“œ êµì²´ â†’ ì¬í™•ì¸
  â†“
ëª¨ë“  ì¹´ë“œ OK â†’ "New Hand" ë²„íŠ¼ í´ë¦­
```

**í•¸ë“œ ì§„í–‰**
```
ì¹´ë“œ ë”œë§ â†’ RFID ìë™ ê°ì§€ â†’ í™”ë©´ì— ì¹´ë“œ í‘œì‹œ í™•ì¸
  â†“
Action Trackerì—ì„œ í”Œë ˆì´ì–´ ì•¡ì…˜ ì…ë ¥
  â†“
Flop/Turn/River ë”œë§ â†’ ë³´ë“œ ì¹´ë“œ ìë™ ì¸ì‹
  â†“
ì‡¼ë‹¤ìš´ ì‹œ ì¹´ë“œ ê³µê°œ â†’ ìŠ¹ì ìë™ ê³„ì‚°
```

#### ğŸ“± Action Tracker ìš´ì˜ì ì›Œí¬í”Œë¡œìš°

**ì—°ê²° ì„¤ì •**
```
Action Tracker ì•± ì‹¤í–‰
  â†“
Server IP ì…ë ¥ (ì˜ˆ: 192.168.1.100)
  â†“
Connect ë²„íŠ¼ í´ë¦­ â†’ ì—°ê²° ìƒíƒœ í™•ì¸ (ë…¹ìƒ‰ = ì—°ê²°ë¨)
```

**ê²Œì„ ì¤‘ ì•¡ì…˜ ì…ë ¥**
```
í˜„ì¬ ì•¡ì…˜í•  í”Œë ˆì´ì–´ í™•ì¸ (ê°•ì¡° í‘œì‹œ)
  â†“
í”Œë ˆì´ì–´ ì•¡ì…˜ ì„ íƒ:
- FOLD: ì¦‰ì‹œ ì²˜ë¦¬
- CHECK: í˜„ì¬ ë² íŒ…ì´ 0ì¼ ë•Œë§Œ
- CALL: ì½œ ê¸ˆì•¡ ìë™ ê³„ì‚°
- RAISE: ê¸ˆì•¡ ì…ë ¥ í•„ìš”
- ALL-IN: ì „ì²´ ìŠ¤íƒ ìë™ ê³„ì‚°
  â†“
í™•ì¸ ë²„íŠ¼ í´ë¦­ â†’ ì„œë²„ë¡œ ì „ì†¡ â†’ ë‹¤ìŒ í”Œë ˆì´ì–´ë¡œ ì´ë™
```

**íŠ¹ìˆ˜ ìƒí™© ì²˜ë¦¬**
```
Run It Twice:
ë©”ë‰´ â†’ Run It Twice â†’ ì²« ë²ˆì§¸ ë¦¬ë²„ ë”œ â†’ "Board 2" ì„ íƒ â†’ ë‘ ë²ˆì§¸ ë¦¬ë²„ ë”œ

Straddle:
í•´ë‹¹ í”Œë ˆì´ì–´ ì„ íƒ â†’ ë©”ë‰´ â†’ Straddle â†’ ê¸ˆì•¡ ì…ë ¥ â†’ ì•¡ì…˜ ìˆœì„œ ìë™ ì¡°ì •

Chop:
ê´€ë ¨ í”Œë ˆì´ì–´ë“¤ ì„ íƒ â†’ ë©”ë‰´ â†’ Chop Pot â†’ íŒŸ ìë™ ë¶„í• 
```

---

## 6. ê¸°ìˆ  êµ¬í˜„ ëª…ì„¸

### ğŸ’» ê°œë°œ í™˜ê²½ ë° ë„êµ¬

#### í•µì‹¬ ê¸°ìˆ  ìŠ¤íƒ
```yaml
ì–¸ì–´:
  - C++17 (ë©”ì¸ ì„œë²„)
  - C# .NET 4.8 (Action Tracker)
  - DirectX 11/12 (ê·¸ë˜í”½)
  - SQL Server Express (ë°ì´í„°ë² ì´ìŠ¤)

ê°œë°œë„êµ¬:
  - Visual Studio 2022 Professional
  - Windows SDK 10.0.22000
  - DirectX SDK
  - Git for version control

ë¼ì´ë¸ŒëŸ¬ë¦¬:
  - Boost 1.80+ (C++ ìœ í‹¸ë¦¬í‹°)
  - JSON for Modern C++ (ë°ì´í„° ì§ë ¬í™”)
  - OpenCV 4.6+ (ì´ë¯¸ì§€ ì²˜ë¦¬)
  - FFmpeg 5.0+ (ë¹„ë””ì˜¤ ì²˜ë¦¬)
  - WebSocket++ (ë„¤íŠ¸ì›Œí¬)
```

#### í”„ë¡œì íŠ¸ êµ¬ì¡°
```
PokerGFX/
â”œâ”€â”€ Server/                 # ë©”ì¸ ì„œë²„ (C++)
â”‚   â”œâ”€â”€ Core/              # í•µì‹¬ ì—”ì§„
â”‚   â”œâ”€â”€ RFID/              # RFID ê´€ë¦¬
â”‚   â”œâ”€â”€ Graphics/          # ë Œë”ë§ ì—”ì§„
â”‚   â”œâ”€â”€ Network/           # ë„¤íŠ¸ì›Œí¬ í†µì‹ 
â”‚   â””â”€â”€ Plugins/           # í™•ì¥ ëª¨ë“ˆ
â”œâ”€â”€ ActionTracker/         # Action Tracker (C#)
â”‚   â”œâ”€â”€ UI/                # Windows Forms
â”‚   â”œâ”€â”€ Network/           # TCP í´ë¼ì´ì–¸íŠ¸
â”‚   â””â”€â”€ Game/              # ê²Œì„ ë¡œì§
â”œâ”€â”€ Studio/                # í¬ìŠ¤íŠ¸ í”„ë¡œë•ì…˜ (C++)
â”‚   â”œâ”€â”€ Timeline/          # íƒ€ì„ë¼ì¸ ì—ë””í„°
â”‚   â”œâ”€â”€ Renderer/          # ë¹„ë””ì˜¤ ë Œë”ëŸ¬
â”‚   â””â”€â”€ Effects/           # íŠ¹ìˆ˜ íš¨ê³¼
â”œâ”€â”€ Common/                # ê³µí†µ ë¼ì´ë¸ŒëŸ¬ë¦¬
â”‚   â”œâ”€â”€ Protocol/          # í†µì‹  í”„ë¡œí† ì½œ
â”‚   â”œâ”€â”€ Utils/             # ìœ í‹¸ë¦¬í‹°
â”‚   â””â”€â”€ Data/              # ë°ì´í„° êµ¬ì¡°
â””â”€â”€ Resources/             # ë¦¬ì†ŒìŠ¤ íŒŒì¼
    â”œâ”€â”€ Skins/             # ê·¸ë˜í”½ ìŠ¤í‚¨
    â”œâ”€â”€ Fonts/             # í°íŠ¸ íŒŒì¼
    â””â”€â”€ Images/            # ì´ë¯¸ì§€ ì—ì…‹
```

### ğŸ”Œ RFID ì‹œìŠ¤í…œ êµ¬í˜„

#### USB í†µì‹  í”„ë¡œí† ì½œ
```cpp
// RFID í†µì‹  í”„ë¡œí† ì½œ êµ¬í˜„
class RFIDProtocol {
private:
    static const uint8_t PACKET_HEADER = 0xAA;
    static const uint8_t PACKET_FOOTER = 0x55;
    
    enum CommandType {
        CMD_GET_VERSION = 0x01,
        CMD_START_READING = 0x02,
        CMD_STOP_READING = 0x03,
        CMD_CALIBRATE = 0x04,
        CMD_GET_STATUS = 0x05
    };
    
    struct PacketHeader {
        uint8_t header;
        uint8_t command;
        uint16_t length;
        uint32_t timestamp;
    };
    
    struct CardDataPacket {
        PacketHeader header;
        char rfidTag[16];
        float positionX;
        float positionY;
        int8_t signalStrength;
        uint8_t checksum;
        uint8_t footer;
    };

public:
    bool SendCommand(CommandType cmd, const void* data = nullptr, size_t dataSize = 0);
    bool ReceiveData(CardDataPacket& packet);
    bool ValidatePacket(const CardDataPacket& packet);
    uint8_t CalculateChecksum(const void* data, size_t size);
};

// USB ë””ë°”ì´ìŠ¤ ì—°ê²° ê´€ë¦¬
class USBManager {
private:
    HANDLE m_deviceHandle;
    OVERLAPPED m_readOverlapped;
    OVERLAPPED m_writeOverlapped;
    
public:
    bool OpenDevice(const std::wstring& devicePath);
    void CloseDevice();
    bool WriteData(const void* data, size_t size);
    bool ReadData(void* buffer, size_t bufferSize, size_t& bytesRead);
    bool IsDeviceConnected();
    
private:
    std::wstring FindRFIDDevice();
    bool SetupOverlappedIO();
};
```

#### ìº˜ë¦¬ë¸Œë ˆì´ì…˜ ì‹œìŠ¤í…œ
```cpp
// í…Œì´ë¸” ìº˜ë¦¬ë¸Œë ˆì´ì…˜ êµ¬í˜„
class TableCalibration {
public:
    struct CalibrationPoint {
        int seatNumber;
        float x, y;          // ë¬¼ë¦¬ì  ì¢Œí‘œ
        float signalStrength; // ì‹ í˜¸ ê°•ë„
        bool isValid;
    };
    
    struct CalibrationData {
        std::vector<CalibrationPoint> playerSeats;
        std::vector<CalibrationPoint> boardPositions;
        CalibrationPoint dealerPosition;
        CalibrationPoint muckArea;
        float tableRadius;
        DateTime calibrationDate;
    };

private:
    CalibrationData m_calibration;
    RFIDManager* m_rfidManager;
    
public:
    bool StartCalibration();
    bool CalibratePosition(int seatNumber);
    bool SetBoardPositions();
    bool ValidateCalibration();
    bool SaveCalibration(const std::string& filename);
    bool LoadCalibration(const std::string& filename);
    
    // ì‹¤ì‹œê°„ ìœ„ì¹˜ ë§¤í•‘
    int MapPositionToSeat(float x, float y);
    bool IsPositionOnBoard(float x, float y);
    
private:
    float CalculateDistance(const CalibrationPoint& p1, const CalibrationPoint& p2);
    bool IsValidSignalStrength(float strength);
    void OptimizePositions(); // ì‹ í˜¸ ê°•ë„ ê¸°ë°˜ ìœ„ì¹˜ ìµœì í™”
};
```

### ğŸ® ê²Œì„ ì—”ì§„ ìƒì„¸ êµ¬í˜„

#### í¬ì»¤ ë£° ì—”ì§„
```cpp
// í¬ì»¤ í•¸ë“œ í‰ê°€ ì‹œìŠ¤í…œ
class HandEvaluator {
public:
    enum HandRank {
        HIGH_CARD = 0,
        PAIR = 1,
        TWO_PAIR = 2,
        THREE_OF_KIND = 3,
        STRAIGHT = 4,
        FLUSH = 5,
        FULL_HOUSE = 6,
        FOUR_OF_KIND = 7,
        STRAIGHT_FLUSH = 8,
        ROYAL_FLUSH = 9
    };
    
    struct HandValue {
        HandRank rank;
        std::vector<int> kickers;
        int numericValue; // ë¹„êµìš© ìˆ«ìê°’
    };

public:
    HandValue EvaluateHand(const std::vector<Card>& cards);
    HandValue GetBestHand(const std::vector<Card>& holeCards, 
                         const std::vector<Card>& boardCards);
    int CompareHands(const HandValue& hand1, const HandValue& hand2);
    std::string GetHandDescription(const HandValue& hand);

private:
    bool IsStraight(const std::vector<Card>& cards);
    bool IsFlush(const std::vector<Card>& cards);
    std::vector<int> GetRankCounts(const std::vector<Card>& cards);
    int CalculateNumericValue(const HandValue& hand);
};

// íŒŸ ê³„ì‚° ë° ì‚¬ì´ë“œíŒŸ ê´€ë¦¬
class PotManager {
public:
    struct Pot {
        double amount;
        std::vector<int> eligiblePlayers;
        bool isMainPot;
        std::string description;
    };

private:
    std::vector<Pot> m_pots;
    double m_totalPot;
    
public:
    void AddBet(int playerId, double amount);
    void CreateSidePot(int allInPlayerId);
    std::vector<Pot> CalculatePots(const std::vector<Player>& players);
    void AwardPot(const Pot& pot, int winnerId);
    void SplitPot(const Pot& pot, const std::vector<int>& winnerIds);
    
private:
    void RecalculateAllPots();
    bool IsPlayerEligible(int playerId, const Pot& pot);
};
```

### ğŸ¨ ê·¸ë˜í”½ ì‹œìŠ¤í…œ ìƒì„¸ êµ¬í˜„

#### DirectX ë Œë”ë§ íŒŒì´í”„ë¼ì¸
```cpp
// DirectX 11 ë Œë”ë§ ì‹œìŠ¤í…œ
class D3D11Renderer {
private:
    // DirectX ê°ì²´ë“¤
    ID3D11Device* m_device;
    ID3D11DeviceContext* m_context;
    IDXGISwapChain* m_swapChain;
    ID3D11RenderTargetView* m_renderTargetView;
    ID3D11DepthStencilView* m_depthStencilView;
    
    // ìƒìˆ˜ ë²„í¼
    ID3D11Buffer* m_constantBuffer;
    ID3D11Buffer* m_vertexBuffer;
    ID3D11Buffer* m_indexBuffer;
    
    // ì…°ì´ë”
    ID3D11VertexShader* m_vertexShader;
    ID3D11PixelShader* m_pixelShader;
    ID3D11InputLayout* m_inputLayout;
    
    // ë¸”ë Œë“œ ìƒíƒœ
    ID3D11BlendState* m_alphaBlendState;
    ID3D11BlendState* m_opaqueBlendState;

public:
    bool Initialize(HWND hwnd, int width, int height);
    void Shutdown();
    
    void BeginFrame();
    void EndFrame();
    void Present();
    
    // ê¸°ë³¸ ë Œë”ë§
    void RenderQuad(const Rect& destRect, ID3D11ShaderResourceView* texture);
    void RenderText(const std::string& text, const Vector2& position, 
                   const Color& color, const Font& font);
    
    // ì¹´ë“œ ë Œë”ë§
    void RenderCard(const Card& card, const Transform& transform, bool faceUp);
    void RenderCardBack(const Transform& transform);
    
    // íš¨ê³¼ ë Œë”ë§
    void RenderGlow(const Vector2& center, float radius, const Color& color);
    void RenderParticles(const std::vector<Particle>& particles);

private:
    bool CreateDeviceAndSwapChain(HWND hwnd, int width, int height);
    bool CreateRenderTargetView();
    bool LoadShaders();
    bool CreateBuffers();
    void SetupBlendStates();
};

// ìŠ¤í‚¨ ì‹œìŠ¤í…œ
class SkinManager {
public:
    struct SkinElement {
        std::string name;
        Vector2 position;
        Vector2 size;
        Color color;
        std::string texturePath;
        Font font;
        std::map<std::string, Variant> properties;
    };
    
    struct Skin {
        std::string name;
        std::string version;
        std::map<std::string, SkinElement> elements;
        std::map<std::string, Animation> animations;
    };

private:
    std::map<std::string, Skin> m_skins;
    Skin* m_currentSkin;
    
public:
    bool LoadSkin(const std::string& skinPath);
    void SetActiveSkin(const std::string& skinName);
    SkinElement* GetElement(const std::string& elementName);
    
    // ë™ì  ìŠ¤í‚¨ ìˆ˜ì •
    void SetElementProperty(const std::string& element, 
                           const std::string& property, 
                           const Variant& value);
                           
private:
    bool ParseSkinXML(const std::string& xmlPath, Skin& skin);
    void LoadSkinTextures(const Skin& skin);
};
```

### ğŸŒ ë„¤íŠ¸ì›Œí¬ í†µì‹  êµ¬í˜„

#### TCP ì„œë²„ (ë©”ì¸ ì„œë²„)
```cpp
// ë¹„ë™ê¸° TCP ì„œë²„
class TCPServer {
public:
    struct ClientInfo {
        SOCKET socket;
        std::string ipAddress;
        ClientType type; // ACTION_TRACKER, STUDIO, API_CLIENT
        DateTime connectTime;
        bool isAuthenticated;
    };

private:
    SOCKET m_listenSocket;
    std::vector<ClientInfo> m_clients;
    std::thread m_acceptThread;
    std::thread m_messageThread;
    std::mutex m_clientsMutex;
    bool m_isRunning;
    
public:
    bool StartServer(int port);
    void StopServer();
    void BroadcastMessage(const std::string& message, ClientType targetType = ALL);
    void SendToClient(int clientId, const std::string& message);
    
    // ì´ë²¤íŠ¸ ì½œë°±
    void SetClientConnectedCallback(std::function<void(ClientInfo)> callback);
    void SetMessageReceivedCallback(std::function<void(int, std::string)> callback);

private:
    void AcceptClientThread();
    void MessageHandlerThread();
    void HandleClientMessage(int clientId, const std::string& message);
    bool AuthenticateClient(int clientId, const std::string& credentials);
    void DisconnectClient(int clientId);
};

// ë©”ì‹œì§€ í”„ë¡œí† ì½œ
class MessageProtocol {
public:
    enum MessageType {
        GAME_STATE_UPDATE,
        PLAYER_ACTION,
        CARD_DETECTED,
        HAND_COMPLETE,
        CLIENT_AUTHENTICATION,
        SYSTEM_STATUS
    };
    
    struct Message {
        MessageType type;
        uint32_t timestamp;
        uint32_t sequenceNumber;
        std::string data; // JSON í˜•ì‹
    };

public:
    std::string SerializeMessage(const Message& msg);
    Message DeserializeMessage(const std::string& data);
    bool ValidateMessage(const Message& msg);

private:
    uint32_t m_sequenceCounter;
    std::string CreateChecksum(const std::string& data);
};
```

#### Action Tracker í´ë¼ì´ì–¸íŠ¸ (C#)
```csharp
// Action Tracker ë„¤íŠ¸ì›Œí¬ í´ë¼ì´ì–¸íŠ¸
public class ActionTrackerClient {
    private TcpClient tcpClient;
    private NetworkStream stream;
    private Thread messageListener;
    private bool isConnected;
    
    // ì´ë²¤íŠ¸
    public event EventHandler<GameStateEventArgs> GameStateUpdated;
    public event EventHandler<ConnectionEventArgs> ConnectionChanged;
    
    public async Task<bool> ConnectAsync(string serverIP, int port) {
        try {
            tcpClient = new TcpClient();
            await tcpClient.ConnectAsync(serverIP, port);
            stream = tcpClient.GetStream();
            
            // ì¸ì¦ ë©”ì‹œì§€ ì „ì†¡
            var authMessage = new AuthenticationMessage {
                ClientType = ClientType.ActionTracker,
                Version = Application.ProductVersion,
                MachineName = Environment.MachineName
            };
            
            await SendMessageAsync(authMessage);
            
            // ë©”ì‹œì§€ ë¦¬ìŠ¤ë„ˆ ì‹œì‘
            messageListener = new Thread(MessageListenerLoop);
            messageListener.Start();
            
            isConnected = true;
            ConnectionChanged?.Invoke(this, new ConnectionEventArgs(true));
            
            return true;
        }
        catch (Exception ex) {
            // ì—°ê²° ì‹¤íŒ¨ ì²˜ë¦¬
            isConnected = false;
            ConnectionChanged?.Invoke(this, new ConnectionEventArgs(false, ex.Message));
            return false;
        }
    }
    
    public async Task SendActionAsync(PlayerAction action) {
        if (!isConnected) return;
        
        var actionMessage = new ActionMessage {
            PlayerId = action.PlayerId,
            ActionType = action.Type,
            Amount = action.Amount,
            Timestamp = DateTime.UtcNow
        };
        
        await SendMessageAsync(actionMessage);
    }
    
    private void MessageListenerLoop() {
        byte[] buffer = new byte[4096];
        
        while (isConnected) {
            try {
                int bytesRead = stream.Read(buffer, 0, buffer.Length);
                if (bytesRead > 0) {
                    string message = Encoding.UTF8.GetString(buffer, 0, bytesRead);
                    ProcessIncomingMessage(message);
                }
            }
            catch (Exception ex) {
                // ì—°ê²° ëŠê¹€ ì²˜ë¦¬
                HandleDisconnection(ex);
                break;
            }
        }
    }
    
    private void ProcessIncomingMessage(string messageData) {
        try {
            var message = JsonConvert.DeserializeObject<NetworkMessage>(messageData);
            
            switch (message.Type) {
                case MessageType.GameStateUpdate:
                    var gameState = JsonConvert.DeserializeObject<GameState>(message.Data);
                    GameStateUpdated?.Invoke(this, new GameStateEventArgs(gameState));
                    break;
                    
                case MessageType.PlayerAction:
                    // ë‹¤ë¥¸ í´ë¼ì´ì–¸íŠ¸ì˜ ì•¡ì…˜ ì²˜ë¦¬
                    break;
                    
                case MessageType.SystemStatus:
                    // ì‹œìŠ¤í…œ ìƒíƒœ ì—…ë°ì´íŠ¸
                    break;
            }
        }
        catch (Exception ex) {
            // ë©”ì‹œì§€ íŒŒì‹± ì˜¤ë¥˜ ì²˜ë¦¬
        }
    }
}
```

---

## 7. ê°œë°œ ë¡œë“œë§µ

### ğŸ“… ì „ì²´ ê°œë°œ ì¼ì • (18ê°œì›”)

#### Phase 1: í•µì‹¬ ì¸í”„ë¼ êµ¬ì¶• (1-4ê°œì›”)

**Month 1-2: ê¸°ë°˜ ì‹œìŠ¤í…œ**
```yaml
ì£¼ìš”ì‘ì—…:
  - Visual Studio í”„ë¡œì íŠ¸ êµ¬ì¡° ì„¤ì •
  - DirectX 11 ë Œë”ë§ íŒŒì´í”„ë¼ì¸ êµ¬í˜„
  - ê¸°ë³¸ Windows Forms UI êµ¬ì„±
  - SQLite ë°ì´í„°ë² ì´ìŠ¤ ìŠ¤í‚¤ë§ˆ ì„¤ê³„
  - ë¡œê¹… ë° ë””ë²„ê¹… ì‹œìŠ¤í…œ êµ¬ì¶•

ì™„ë£Œê¸°ì¤€:
  - ë¹ˆ ì°½ì— DirectX ë Œë”ë§ ì„±ê³µ
  - ê¸°ë³¸ ë„¤íŠ¸ì›Œí¬ í†µì‹  êµ¬í˜„
  - í”„ë¡œì íŠ¸ ë¹Œë“œ ìë™í™” ì™„ë£Œ
  - ì½”ë“œ ë¦¬ë·° í”„ë¡œì„¸ìŠ¤ í™•ë¦½
```

**Month 3-4: RFID ì‹œìŠ¤í…œ**
```yaml
ì£¼ìš”ì‘ì—…:
  - USB í†µì‹  ë“œë¼ì´ë²„ êµ¬í˜„
  - RFID ë°ì´í„° íŒŒì‹± ë¡œì§
  - ìº˜ë¦¬ë¸Œë ˆì´ì…˜ UI ë° ë¡œì§
  - ì¹´ë“œ ë“±ë¡ ì‹œìŠ¤í…œ
  - ì‹¤ì‹œê°„ ì¹´ë“œ ê°ì§€ í…ŒìŠ¤íŠ¸

ì™„ë£Œê¸°ì¤€:
  - 52ì¥ ì¹´ë“œ ë“±ë¡ ì„±ê³µ
  - í…Œì´ë¸” ìº˜ë¦¬ë¸Œë ˆì´ì…˜ ì™„ë£Œ
  - ì‹¤ì‹œê°„ ì¹´ë“œ ê°ì§€ 95% ì •í™•ë„
  - ë‹¤ì¤‘ ì¹´ë“œ ë™ì‹œ ê°ì§€ ì§€ì›
```

#### Phase 2: ê²Œì„ ë¡œì§ êµ¬í˜„ (5-8ê°œì›”)

**Month 5-6: í¬ì»¤ ì—”ì§„**
```yaml
ì£¼ìš”ì‘ì—…:
  - Hold'em ê²Œì„ ë£° êµ¬í˜„
  - í•¸ë“œ í‰ê°€ ì‹œìŠ¤í…œ
  - ë² íŒ… ë¼ìš´ë“œ ê´€ë¦¬
  - íŒŸ ê³„ì‚° ë¡œì§
  - í”Œë ˆì´ì–´ ìƒíƒœ ê´€ë¦¬

ì™„ë£Œê¸°ì¤€:
  - ì™„ì „í•œ Hold'em ê²Œì„ ì§„í–‰
  - ì •í™•í•œ í•¸ë“œ ë­í‚¹ ê³„ì‚°
  - ì‚¬ì´ë“œíŒŸ ì²˜ë¦¬ ì™„ë£Œ
  - ì˜¬ì¸ ìƒí™© ì²˜ë¦¬ ì™„ë£Œ
```

**Month 7-8: Action Tracker**
```yaml
ì£¼ìš”ì‘ì—…:
  - Windows Forms UI ì™„ì„±
  - TCP í´ë¼ì´ì–¸íŠ¸ êµ¬í˜„
  - ì‹¤ì‹œê°„ ê²Œì„ ìƒíƒœ ë™ê¸°í™”
  - í„°ì¹˜ìŠ¤í¬ë¦° ì§€ì›
  - í‚¤ë³´ë“œ ë‹¨ì¶•í‚¤ êµ¬í˜„

ì™„ë£Œê¸°ì¤€:
  - ì•ˆì •ì ì¸ ë„¤íŠ¸ì›Œí¬ ì—°ê²°
  - ëª¨ë“  í”Œë ˆì´ì–´ ì•¡ì…˜ ì§€ì›
  - ì‹¤ì‹œê°„ UI ì—…ë°ì´íŠ¸
  - ë‹¤ì¤‘ í…Œì´ë¸” ì§€ì›
```

#### Phase 3: ê·¸ë˜í”½ ì‹œìŠ¤í…œ (9-12ê°œì›”)

**Month 9-10: ê¸°ë³¸ ê·¸ë˜í”½**
```yaml
ì£¼ìš”ì‘ì—…:
  - ì¹´ë“œ ë Œë”ë§ ì‹œìŠ¤í…œ
  - í”Œë ˆì´ì–´ ì •ë³´ í‘œì‹œ
  - íŒŸ ë° ë² íŒ… ì •ë³´
  - ê¸°ë³¸ ì• ë‹ˆë©”ì´ì…˜
  - ìŠ¤í‚¨ ì‹œìŠ¤í…œ ê¸°ì´ˆ

ì™„ë£Œê¸°ì¤€:
  - ëª¨ë“  ê²Œì„ ìš”ì†Œ ì‹œê°í™”
  - 60fps ì•ˆì •ì  ë Œë”ë§
  - ì•ŒíŒŒ ì±„ë„ ì§€ì›
  - ê¸°ë³¸ ì „í™˜ íš¨ê³¼
```

**Month 11-12: ê³ ê¸‰ ê·¸ë˜í”½**
```yaml
ì£¼ìš”ì‘ì—…:
  - ê³ ê¸‰ ì• ë‹ˆë©”ì´ì…˜ ì‹œìŠ¤í…œ
  - íŒŒí‹°í´ íš¨ê³¼
  - ì»¤ìŠ¤í…€ ìŠ¤í‚¨ ì§€ì›
  - 4K í•´ìƒë„ ì§€ì›
  - ì„±ëŠ¥ ìµœì í™”

ì™„ë£Œê¸°ì¤€:
  - ë°©ì†¡ í’ˆì§ˆ ê·¸ë˜í”½ ì¶œë ¥
  - ë‹¤ì–‘í•œ í•´ìƒë„ ì§€ì›
  - ì»¤ìŠ¤í„°ë§ˆì´ì§• ê°€ëŠ¥í•œ UI
  - ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ìµœì í™”
```

#### Phase 4: ë°©ì†¡/ìŠ¤íŠ¸ë¦¬ë° ê¸°ëŠ¥ (13-15ê°œì›”)

**Month 13-14: ë¹„ë””ì˜¤ ì¶œë ¥**
```yaml
ì£¼ìš”ì‘ì—…:
  - OBS ì—°ë™ (WebSocket)
  - ë‹¤ì¤‘ ë¹„ë””ì˜¤ ì†ŒìŠ¤ ì§€ì›
  - ìŠ¤íŠ¸ë¦¬ë° í”Œë«í¼ ì—°ë™
  - ë…¹í™” ê¸°ëŠ¥
  - ì§€ì—° ë°©ì†¡ ì‹œìŠ¤í…œ

ì™„ë£Œê¸°ì¤€:
  - Twitch/YouTube ìŠ¤íŠ¸ë¦¬ë°
  - ìµœëŒ€ 8ê°œ ì¹´ë©”ë¼ ì§€ì›
  - ë³´ì•ˆ ì§€ì—° ì‹œìŠ¤í…œ ì™„ë£Œ
  - HD/4K ë…¹í™” ì§€ì›
```

**Month 15: ê³ ê¸‰ ë°©ì†¡ ê¸°ëŠ¥**
```yaml
ì£¼ìš”ì‘ì—…:
  - ATEM ìŠ¤ìœ„ì²˜ ì œì–´
  - NDI ì…ì¶œë ¥ ì§€ì›
  - ì˜¤ë””ì˜¤ ë¯¹ì‹±
  - ë‹¤ì¤‘ ì¶œë ¥ ì§€ì›
  - ì‹¤ì‹œê°„ í†µê³„ í‘œì‹œ

ì™„ë£Œê¸°ì¤€:
  - ì „ë¬¸ ë°©ì†¡ ì¥ë¹„ ì—°ë™
  - ì•ˆì •ì ì¸ ë‹¤ì¤‘ ì¶œë ¥
  - ì˜¤ë””ì˜¤ ë™ê¸°í™” ì™„ë£Œ
  - ì‹¤ì‹œê°„ ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§
```

#### Phase 5: Studio ë° ê³ ê¸‰ ê¸°ëŠ¥ (16-18ê°œì›”)

**Month 16-17: Studio êµ¬í˜„**
```yaml
ì£¼ìš”ì‘ì—…:
  - í¬ìŠ¤íŠ¸ í”„ë¡œë•ì…˜ ì—ë””í„°
  - íƒ€ì„ë¼ì¸ í¸ì§‘ê¸°
  - ë¹„ë””ì˜¤ ë Œë”ë§ ì—”ì§„
  - í•¸ë“œ íˆìŠ¤í† ë¦¬ í¸ì§‘
  - ë°°ì¹˜ ì²˜ë¦¬ ì‹œìŠ¤í…œ

ì™„ë£Œê¸°ì¤€:
  - ì™„ì „í•œ í¸ì§‘ ì›Œí¬í”Œë¡œìš°
  - ë‹¤ì–‘í•œ ì¶œë ¥ í¬ë§· ì§€ì›
  - ê³ í’ˆì§ˆ ë Œë”ë§
  - ìë™í™”ëœ ì²˜ë¦¬
```

**Month 18: ìµœì¢… ì™„ì„±**
```yaml
ì£¼ìš”ì‘ì—…:
  - ì¢…í•© í…ŒìŠ¤íŠ¸ ë° ë²„ê·¸ ìˆ˜ì •
  - ì„±ëŠ¥ ìµœì í™”
  - ì‚¬ìš©ì ë§¤ë‰´ì–¼ ì‘ì„±
  - ì„¤ì¹˜ í”„ë¡œê·¸ë¨ ì œì‘
  - ë¼ì´ì„ ìŠ¤ ì‹œìŠ¤í…œ êµ¬í˜„

ì™„ë£Œê¸°ì¤€:
  - ëª¨ë“  ê¸°ëŠ¥ ê²€ì¦ ì™„ë£Œ
  - 24ì‹œê°„ ì—°ì† ì•ˆì •ì„± í…ŒìŠ¤íŠ¸
  - ì™„ì „í•œ ë¬¸ì„œí™”
  - ë°°í¬ ì¤€ë¹„ ì™„ë£Œ
```

### ğŸ‘¥ ê°œë°œíŒ€ êµ¬ì„±

#### í•„ìˆ˜ ì¸ë ¥ (8ëª…)
```yaml
Tech Lead (1ëª…):
  - ì „ì²´ ì•„í‚¤í…ì²˜ ì„¤ê³„
  - ì½”ë“œ ë¦¬ë·° ë° í’ˆì§ˆ ê´€ë¦¬
  - ê¸°ìˆ ì  ì˜ì‚¬ê²°ì •

C++ ê°œë°œì (3ëª…):
  - ë©”ì¸ ì„œë²„ ê°œë°œ
  - RFID ì‹œìŠ¤í…œ êµ¬í˜„
  - ê·¸ë˜í”½ ì—”ì§„ ê°œë°œ

C# ê°œë°œì (2ëª…):
  - Action Tracker ê°œë°œ
  - Studio ì• í”Œë¦¬ì¼€ì´ì…˜
  - UI/UX êµ¬í˜„

DirectX/Graphics ì „ë¬¸ê°€ (1ëª…):
  - ë Œë”ë§ íŒŒì´í”„ë¼ì¸
  - ì…°ì´ë” í”„ë¡œê·¸ë˜ë°
  - ì„±ëŠ¥ ìµœì í™”

QA ì—”ì§€ë‹ˆì–´ (1ëª…):
  - í…ŒìŠ¤íŠ¸ ì‹œë‚˜ë¦¬ì˜¤ ì‘ì„±
  - ìë™í™” í…ŒìŠ¤íŠ¸ êµ¬ì¶•
  - ë²„ê·¸ ì¶”ì  ë° ê²€ì¦
```

### ğŸ’° ì˜ˆì‚° ê³„íš

#### ì´ ê°œë°œ ë¹„ìš©: $2.8M (18ê°œì›”)
```yaml
ì¸ê±´ë¹„: $2.1M (75%)
  - Tech Lead: $200K/ë…„ Ã— 1.5ë…„ = $300K
  - Senior C++: $150K/ë…„ Ã— 1.5ë…„ Ã— 3ëª… = $675K
  - C# ê°œë°œì: $130K/ë…„ Ã— 1.5ë…„ Ã— 2ëª… = $390K
  - Graphics ì „ë¬¸ê°€: $160K/ë…„ Ã— 1.5ë…„ = $240K
  - QA ì—”ì§€ë‹ˆì–´: $100K/ë…„ Ã— 1.5ë…„ = $150K
  - í”„ë¡œì íŠ¸ ê´€ë¦¬: $20K/ì›” Ã— 18ê°œì›” = $360K

ë„êµ¬ ë° ë¼ì´ì„ ìŠ¤: $200K (7%)
  - Visual Studio Professional: $45/ì›” Ã— 8ëª… Ã— 18ê°œì›” = $6.5K
  - DirectX SDK: ë¬´ë£Œ
  - 3rd party ë¼ì´ë¸ŒëŸ¬ë¦¬: $50K
  - í…ŒìŠ¤íŠ¸ ì¥ë¹„: $100K
  - ê°œë°œ PC (ê³ ì‚¬ì–‘): $5K Ã— 8ëŒ€ = $40K

ì¸í”„ë¼: $150K (5%)
  - í´ë¼ìš°ë“œ ì„œë²„: $2K/ì›” Ã— 18ê°œì›” = $36K
  - ë²„ì „ ê´€ë¦¬ ì‹œìŠ¤í…œ: $50/ì›” Ã— 18ê°œì›” = $0.9K
  - CI/CD íŒŒì´í”„ë¼ì¸: $100/ì›” Ã— 18ê°œì›” = $1.8K
  - í…ŒìŠ¤íŠ¸ í™˜ê²½ êµ¬ì¶•: $50K
  - ì˜¤í”¼ìŠ¤ ê³µê°„ ë° ìœ í‹¸ë¦¬í‹°: $60K

ê¸°íƒ€: $350K (13%)
  - ë²•ë¬´ ë° íŠ¹í—ˆ: $50K
  - ë§ˆì¼€íŒ… ë° ë¸Œëœë”©: $100K
  - ì‚¬ìš©ì í…ŒìŠ¤íŠ¸: $50K
  - ì˜ˆë¹„ ë¹„ìš©: $150K
```

---

## ğŸ“‹ ê²°ë¡ 

ì´ ê¸°íšì„œëŠ” **PokerGFXì˜ ëª¨ë“  ê¸°ëŠ¥ì„ ì™„ì „íˆ ë³µì œ**í•˜ê¸° ìœ„í•œ ìƒì„¸í•œ ê°œë°œ ê³„íšì„ ì œì‹œí•©ë‹ˆë‹¤. 

### âœ… í•µì‹¬ ë‹¬ì„± ëª©í‘œ
1. **100% ê¸°ëŠ¥ ë™ì¼ì„±**: ì›ë³¸ê³¼ ë™ì¼í•œ ëª¨ë“  ê¸°ëŠ¥ êµ¬í˜„
2. **ì„±ëŠ¥ ë™ë“±ì„±**: ë™ì¼í•œ ìˆ˜ì¤€ì˜ ì„±ëŠ¥ê³¼ ì•ˆì •ì„±
3. **ì‚¬ìš©ì ê²½í—˜**: ê¸°ì¡´ ì‚¬ìš©ìê°€ ë°”ë¡œ ì‚¬ìš© ê°€ëŠ¥í•œ ì¸í„°í˜ì´ìŠ¤
4. **ê¸°ìˆ ì  ì™„ì„±ë„**: ìƒìš© ì†Œí”„íŠ¸ì›¨ì–´ ìˆ˜ì¤€ì˜ í’ˆì§ˆ

### ğŸ¯ ì„±ê³µ ì§€í‘œ
- RFID ì¹´ë“œ ì¸ì‹ ì •í™•ë„: 99.5% ì´ìƒ
- ì‹¤ì‹œê°„ ë Œë”ë§: 60fps ìœ ì§€
- ë„¤íŠ¸ì›Œí¬ ì§€ì—°ì‹œê°„: 50ms ì´í•˜
- ì‹œìŠ¤í…œ ì•ˆì •ì„±: 24ì‹œê°„ ì—°ì† ì‘ë™
- ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰: 8GB ì´í•˜ (4K ìŠ¤íŠ¸ë¦¬ë° ì‹œ)

ì´ì œ ì´ ê¸°íšì„œë¥¼ ë°”íƒ•ìœ¼ë¡œ ê°œë°œíŒ€ì€ **ì‹¤ì œ êµ¬í˜„ ê°€ëŠ¥í•œ ëª…í™•í•œ ë¡œë“œë§µ**ì„ ê°€ì§€ê³  PokerGFXì™€ ë™ì¼í•œ ìˆ˜ì¤€ì˜ ì „ë¬¸ì ì¸ í¬ì»¤ ë°©ì†¡ ì†”ë£¨ì…˜ì„ ê°œë°œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.